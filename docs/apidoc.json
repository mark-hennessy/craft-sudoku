[
  {
    "kind": "library",
    "comment": "\nThe matcher library provides a 3rd generation assertion mechanism, drawing\ninspiration from [Hamcrest] and Ladislav Thon's [dart-matchers]\nlibrary.\n\nSee [Hamcrest] http://en.wikipedia.org/wiki/Hamcrest\n    [Hamcrest] http://code.google.com/p/hamcrest/\n    [dart-matchers] https://github.com/Ladicek/dart-matchers\n",
    "name": "matcher",
    "children": [
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher that matches if the match argument is a string and\nmatches the regular expression given by [re]. [re] can be a RegExp\ninstance or a string; in the latter case it will be used to create\na RegExp instance.\n",
        "name": "matches",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "re",
            "id": "re"
          }
        ],
        "id": "matches1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher that matches if the match argument is a string and\ncontains a given list of [substrings] in relative order.\n\nFor example, `stringContainsInOrder([\"a\", \"e\", \"i\", \"o\", \"u\"])` will match\n\"abcdefghijklmnopqrstuvwxyz\".\n",
        "name": "stringContainsInOrder",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "substrings",
            "id": "substrings"
          }
        ],
        "id": "stringContainsInOrder1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher that matches if the match argument is a string and\nends with [suffixString].\n",
        "name": "endsWith",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "suffixString",
            "id": "suffixString"
          }
        ],
        "id": "endsWith1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher that matches if the match argument is a string and\nstarts with [prefixString].\n",
        "name": "startsWith",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "prefixString",
            "id": "prefixString"
          }
        ],
        "id": "startsWith1()"
      },
      {
        "returnType": {
          "name": "String",
          "refId": "String"
        },
        "kind": "method",
        "comment": "\nUtility function to collapse whitespace runs to single spaces\nand strip leading/trailing whitespace.\n",
        "name": "collapseWhitespace",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "_string",
            "id": "_string"
          }
        ],
        "id": "collapseWhitespace1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches if the match argument is a string and\nis equal to [value] when compared with all runs of whitespace\ncollapsed to single spaces and leading and trailing whitespace removed.\n\nFor example, `equalsIgnoringCase(\"hello world\")` will match\n\"hello   world\", \"  hello world\" and \"hello world  \".\n",
        "name": "equalsIgnoringWhitespace",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "_string",
            "id": "_string"
          }
        ],
        "id": "equalsIgnoringWhitespace1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "name": "equalsIgnoringCase",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "equalsIgnoringCase1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nMatches if any of the given matchers evaluate to true. The\narguments can be a set of matchers as separate parameters\n(up to 7), or a List of matchers.\n\nThe matchers are evaluated from left to right using short-circuit\nevaluation, so evaluation stops as soon as a matcher returns true.\n\nAny argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.\n",
        "name": "anyOf",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "arg0",
            "id": "arg0"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg1",
            "id": "arg1"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg2",
            "id": "arg2"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg3",
            "id": "arg3"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg4",
            "id": "arg4"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg5",
            "id": "arg5"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg6",
            "id": "arg6"
          }
        ],
        "id": "anyOf7()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nThis returns a matcher that matches if all of the matchers passed as\narguments (up to 7) match. Instead of passing the matchers separately\nthey can be passed as a single List argument.\nAny argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.\n",
        "name": "allOf",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "arg0",
            "id": "arg0"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg1",
            "id": "arg1"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg2",
            "id": "arg2"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg3",
            "id": "arg3"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg4",
            "id": "arg4"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg5",
            "id": "arg5"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg6",
            "id": "arg6"
          }
        ],
        "id": "allOf7()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nThis returns a matcher that inverts [matcher] to its logical negation.\n",
        "name": "isNot",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "matcher",
            "id": "matcher"
          }
        ],
        "id": "isNot1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches if the match argument is greater\nthan or equal to a [low] and less than [high].\n",
        "name": "inClosedOpenRange",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "low",
            "id": "low"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "high",
            "id": "high"
          }
        ],
        "id": "inClosedOpenRange2()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches if the match argument is greater\nthan [low] and less than or equal to [high].\n",
        "name": "inOpenClosedRange",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "low",
            "id": "low"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "high",
            "id": "high"
          }
        ],
        "id": "inOpenClosedRange2()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches if the match argument is greater\nthan [low] and less than [high].\n",
        "name": "inExclusiveRange",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "low",
            "id": "low"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "high",
            "id": "high"
          }
        ],
        "id": "inExclusiveRange2()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches if the match argument is greater\nthan or equal to [low] and less than or equal to [high].\n",
        "name": "inInclusiveRange",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "low",
            "id": "low"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "high",
            "id": "high"
          }
        ],
        "id": "inInclusiveRange2()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches if the match argument is within [delta]\nof some [value]; i.e. if the match argument is greater than\nthan or equal [value]-[delta] and less than or equal to [value]+[delta].\n",
        "name": "closeTo",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "delta",
            "id": "delta"
          }
        ],
        "id": "closeTo2()"
      },
      {
        "returnType": {
          "name": "bool",
          "refId": "bool"
        },
        "kind": "method",
        "name": "_isNumeric",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "_isNumeric1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches if the match argument is less\nthan or equal to the given [value].\n",
        "name": "lessThanOrEqualTo",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "lessThanOrEqualTo1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches if the match argument is less\nthan the given [value].\n",
        "name": "lessThan",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "lessThan1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches if the match argument is greater\nthan or equal to the given [value].\n",
        "name": "greaterThanOrEqualTo",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "greaterThanOrEqualTo1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "name": "greaterThan",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "greaterThan1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches maps containing the key-value pair\nwith [key] => [value].\n",
        "name": "containsPair",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "key",
            "id": "key"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "containsPair2()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "name": "containsValue",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "containsValue1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nMatches a [Future] that completes succesfully with a value that matches\n[matcher]. Note that this creates an asynchronous expectation. The call to\n`expect()` that includes this will return immediately and execution will\ncontinue. Later, when the future completes, the actual expectation will run.\n\nTo test that a Future completes with an exception, you can use [throws] and\n[throwsA].\n",
        "name": "completion",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "matcher",
            "id": "matcher"
          }
        ],
        "id": "completion1()"
      },
      {
        "returnType": {
          "name": "ErrorFormatter",
          "refId": "ErrorFormatter"
        },
        "kind": "method",
        "comment": "\nChanges or resets to default the failure message formatter for expect().\n[formatter] is a reference to the new formatter; if this is omitted or\nnull then the failure formatter is reset to the default. The new\nformatter is returned; this allows custom expect handlers to easily\nget a reference to the default formatter.\n",
        "name": "configureExpectFormatter",
        "children": [
          {
            "ref": {
              "name": "ErrorFormatter",
              "refId": "ErrorFormatter"
            },
            "isOptional": true,
            "kind": "param",
            "name": "formatter",
            "id": "formatter"
          }
        ],
        "id": "configureExpectFormatter1()"
      },
      {
        "returnType": {
          "name": "String",
          "refId": "String"
        },
        "kind": "method",
        "name": "_defaultErrorFormatter",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "actual",
            "id": "actual"
          },
          {
            "ref": {
              "name": "Matcher",
              "refId": "Matcher"
            },
            "kind": "param",
            "name": "matcher",
            "id": "matcher"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "reason",
            "id": "reason"
          },
          {
            "ref": {
              "name": "MatchState",
              "refId": "MatchState"
            },
            "kind": "param",
            "name": "matchState",
            "id": "matchState"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "param",
            "name": "verbose",
            "id": "verbose"
          }
        ],
        "id": "_defaultErrorFormatter5()"
      },
      {
        "returnType": {
          "name": "FailureHandler",
          "refId": "FailureHandler"
        },
        "kind": "method",
        "name": "getOrCreateExpectFailureHandler",
        "id": "getOrCreateExpectFailureHandler0()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nChanges or resets to the default the failure handler for expect()\n[handler] is a reference to the new handler; if this is omitted\nor null then the failure handler is reset to the default, which\nthrows [ExpectExceptions] on [expect] assertion failures.\n",
        "name": "configureExpectFailureHandler",
        "children": [
          {
            "ref": {
              "name": "FailureHandler",
              "refId": "FailureHandler"
            },
            "isOptional": true,
            "kind": "param",
            "name": "handler",
            "id": "handler"
          }
        ],
        "id": "configureExpectFailureHandler1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nTakes an argument and returns an equivalent matcher.\nIf the argument is already a matcher this does nothing,\nelse if the argument is a function, it generates a predicate\nfunction matcher, else it generates an equals matcher.\n",
        "name": "wrapMatcher",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "x",
            "id": "x"
          }
        ],
        "id": "wrapMatcher1()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nThis is the main assertion function. It asserts that [actual]\nmatches the [matcher]. [reason] is optional and is typically not\nsupplied, as a reason is generated from the matcher; if [reason]\nis included it is appended to the reason generated by the matcher.\n\n[matcher] can be a value in which case it will be wrapped in an\n[equals] matcher.\n\nIf the assertion fails, then the default behavior is to throw an\n[ExpectException], but this behavior can be changed by calling\n[configureExpectFailureHandler] and providing an alternative handler that\nimplements the [IFailureHandler] interface. It is also possible to\npass a [failureHandler] to [expect] as a final parameter for fine-\ngrained control.\n\nIn some cases extra diagnostic info can be produced on failure (for\nexample, stack traces on mismatched exceptions). To enable these,\n[verbose] should be specified as true;\n",
        "name": "expect",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "actual",
            "id": "actual"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "matcher",
            "id": "matcher"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "isOptional": true,
            "kind": "param",
            "name": "reason",
            "id": "reason"
          },
          {
            "ref": {
              "name": "FailureHandler",
              "refId": "FailureHandler"
            },
            "isOptional": true,
            "kind": "param",
            "name": "failureHandler",
            "id": "failureHandler"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "isOptional": true,
            "kind": "param",
            "name": "verbose",
            "id": "verbose"
          }
        ],
        "id": "expect5()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher that uses an arbitrary function that returns\ntrue or false for the actual value.\n",
        "name": "predicate",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "f",
            "id": "f"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "description",
            "id": "description"
          }
        ],
        "id": "predicate2()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher that matches if the match argument is in\nthe expected value. This is the converse of [contains].\n",
        "name": "isIn",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "expected",
            "id": "expected"
          }
        ],
        "id": "isIn1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher that matches if the match argument contains\nthe expected value. For [String]s this means substring matching;\nfor [Map]s is means the map has the key, and for [Collection]s it\nmeans the collection has a matching element. In the case of collections,\n[expected] can itself be a matcher.\n",
        "name": "contains",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "expected",
            "id": "expected"
          }
        ],
        "id": "contains1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher that matches if an object has a length property\nthat matches [matcher].\n",
        "name": "hasLength",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "matcher",
            "id": "matcher"
          }
        ],
        "id": "hasLength1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nThis can be used to match two kinds of objects:\n\n  * A [Function] that throws an exception when called. The function cannot\n    take any arguments. If you want to test that a function expecting\n    arguments throws, wrap it in another zero-argument function that calls\n    the one you want to test.\n\n  * A [Future] that completes with an exception. Note that this creates an\n    asynchronous expectation. The call to `expect()` that includes this will\n    return immediately and execution will continue. Later, when the future\n    completes, the actual expectation will run.\n\nIn both cases, when an exception is thrown, this will test that the exception\nobject matches [matcher]. If [matcher] is not an instance of [Matcher], it\nwill implicitly be treated as `equals(matcher)`.\n",
        "name": "throwsA",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "matcher",
            "id": "matcher"
          }
        ],
        "id": "throwsA1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher that does a deep recursive match. This only works\nwith scalars, Maps and Iterables. To handle cyclic structures a\nrecursion depth [limit] can be provided. The default limit is 100.\n",
        "name": "equals",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "expected",
            "id": "expected"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "limit",
            "id": "limit"
          }
        ],
        "id": "equals2()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matches that matches if the value is the same instance\nas [object] (`===`).\n",
        "name": "same",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "expected",
            "id": "expected"
          }
        ],
        "id": "same1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches [Iterable]s that have the same\nlength and the same elements as [expected], but not necessarily in\nthe same order. Note that this is O(n^2) so should only be used on\nsmall objects.\n",
        "name": "unorderedEquals",
        "children": [
          {
            "ref": {
              "name": "Iterable",
              "refId": "Iterable"
            },
            "kind": "param",
            "name": "expected",
            "id": "expected"
          }
        ],
        "id": "unorderedEquals1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches [Iterable]s that have the same\nlength and the same elements as [expected], and in the same order.\nThis is equivalent to equals but does not recurse.\n",
        "name": "orderedEquals",
        "children": [
          {
            "ref": {
              "name": "Iterable",
              "refId": "Iterable"
            },
            "kind": "param",
            "name": "expected",
            "id": "expected"
          }
        ],
        "id": "orderedEquals1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\nReturns a matcher which matches [Collection]s in which at least one\nelement matches the given [matcher].\n",
        "name": "someElement",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "matcher",
            "id": "matcher"
          }
        ],
        "id": "someElement1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "name": "everyElement",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "matcher",
            "id": "matcher"
          }
        ],
        "id": "everyElement1()"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isNonNegative",
        "id": "isNonNegative"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isNegative",
        "id": "isNegative"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isNonPositive",
        "id": "isNonPositive"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isPositive",
        "id": "isPositive"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isNonZero",
        "id": "isNonZero"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isZero",
        "id": "isZero"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "completes",
        "id": "completes"
      },
      {
        "ref": {
          "name": "ErrorFormatter",
          "refId": "ErrorFormatter"
        },
        "kind": "property",
        "name": "_assertErrorFormatter",
        "id": "_assertErrorFormatter"
      },
      {
        "ref": {
          "name": "FailureHandler",
          "refId": "FailureHandler"
        },
        "kind": "property",
        "name": "_assertFailureHandler",
        "id": "_assertFailureHandler"
      },
      {
        "ref": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "property",
        "name": "wrapAsync",
        "id": "wrapAsync"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "isList",
        "id": "isList"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "isMap",
        "id": "isMap"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "throwsUnsupportedError",
        "id": "throwsUnsupportedError"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "isUnsupportedError",
        "id": "isUnsupportedError"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "throwsUnimplementedError",
        "id": "throwsUnimplementedError"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "isUnimplementedError",
        "id": "isUnimplementedError"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "throwsNoSuchMethodError",
        "id": "throwsNoSuchMethodError"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "isNoSuchMethodError",
        "id": "isNoSuchMethodError"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "throwsRangeError",
        "id": "throwsRangeError"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "isRangeError",
        "id": "isRangeError"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "throwsIllegalJSRegExpException",
        "id": "throwsIllegalJSRegExpException"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "isIllegalJSRegExpException",
        "id": "isIllegalJSRegExpException"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "throwsArgumentError",
        "id": "throwsArgumentError"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "isArgumentError",
        "id": "isArgumentError"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "throwsException",
        "id": "throwsException"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "isException",
        "id": "isException"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "throwsFormatException",
        "id": "throwsFormatException"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "isFormatException",
        "id": "isFormatException"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "returnsNormally",
        "id": "returnsNormally"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "throws",
        "id": "throws"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "anything",
        "id": "anything"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isFalse",
        "id": "isFalse"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isTrue",
        "id": "isTrue"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isNotNull",
        "id": "isNotNull"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isNull",
        "id": "isNull"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "isEmpty",
        "id": "isEmpty"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nFailed matches are reported using a default IFailureHandler.\nThe default implementation simply throws ExpectExceptions;\nthis can be replaced by some other implementation of\nIFailureHandler by calling configureExpectHandler.\n",
        "name": "FailureHandler",
        "children": [
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "This handles failures given a textual decription ",
            "name": "fail",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "reason",
                "id": "reason"
              }
            ],
            "id": "fail1()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nThis handles failures given the actual [value], the [matcher]\nthe [reason] (argument from [expect]), some additonal [matchState]\ngenerated by the [matcher], and a verbose flag which controls in\nsome cases how much [matchState] information is used. It will use\nthese to create a detailed error message (typically by calling\nan [ErrorFormatter]) and then call [fail] with this message.\n",
            "name": "failMatch",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "actual",
                "id": "actual"
              },
              {
                "ref": {
                  "name": "Matcher",
                  "refId": "Matcher"
                },
                "kind": "param",
                "name": "matcher",
                "id": "matcher"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "reason",
                "id": "reason"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "verbose",
                "id": "verbose"
              }
            ],
            "id": "failMatch5()"
          }
        ],
        "id": "FailureHandler"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\n[expect] Matchers must implement the Matcher class.\nThe base Matcher class that implements this interface has\na generic implementation of [describeMismatch] so this does\nnot need to be provided unless a more clear description is\nrequired. The other two methods ([matches] and [describe])\nmust always be provided as they are highly matcher-specific.\n",
        "name": "Matcher",
        "children": [
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "comment": "\nThis does the matching of the actual vs expected values.\n[item] is the actual value. [matchState] can be supplied\nand may be used to add details about the mismatch that are too\ncostly to determine in [describeMismatch].\n",
            "name": "matches",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "item",
                "id": "item"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              }
            ],
            "id": "matches2()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "This builds a textual description of the matcher. ",
            "name": "describe",
            "children": [
              {
                "ref": {
                  "name": "Description",
                  "refId": "Description"
                },
                "kind": "param",
                "name": "description",
                "id": "description"
              }
            ],
            "id": "describe1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "\nThis builds a textual description of a specific mismatch. [item]\nis the value that was tested by [matches]; [matchState] is\nthe [MatchState] that was passed to and supplemented by [matches]\nwith additional information about the mismact, and [mismatchDescription]\nis the [Description] that is being built to decribe the mismatch.\nA few matchers make use of the [verbose] flag to provide detailed\ninformation that is not typically included but can be of help in\ndiagnosing failures, such as stack traces.\n",
            "name": "describeMismatch",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "item",
                "id": "item"
              },
              {
                "ref": {
                  "name": "Description",
                  "refId": "Description"
                },
                "kind": "param",
                "name": "mismatchDescription",
                "id": "mismatchDescription"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "verbose",
                "id": "verbose"
              }
            ],
            "id": "describeMismatch4()"
          }
        ],
        "id": "Matcher"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nMatchers build up their error messages by appending to\nDescription objects. This interface is implemented by\nStringDescription. This interface is unlikely to need\nother implementations, but could be useful to replace in\nsome cases - e.g. language conversion.\n",
        "name": "Description",
        "children": [
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "Change the value of the description. ",
            "name": "replace",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "text",
                "id": "text"
              }
            ],
            "id": "replace1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "This is used to add arbitrary text to the description. ",
            "name": "add",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "text",
                "id": "text"
              }
            ],
            "id": "add1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "This is used to add a meaningful description of a value. ",
            "name": "addDescriptionOf",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "addDescriptionOf1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "\nThis is used to add a description of an [Iterable] [list],\nwith appropriate [start] and [end] markers and inter-element [separator].\n",
            "name": "addAll",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "start",
                "id": "start"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "separator",
                "id": "separator"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "end",
                "id": "end"
              },
              {
                "ref": {
                  "name": "Iterable",
                  "refId": "Iterable"
                },
                "kind": "param",
                "name": "list",
                "id": "list"
              }
            ],
            "id": "addAll4()"
          }
        ],
        "id": "Description"
      },
      {
        "kind": "typedef",
        "name": "ErrorFormatter",
        "id": "ErrorFormatter"
      },
      {
        "interfaces": [
          {
            "name": "FailureHandler",
            "refId": "FailureHandler"
          }
        ],
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "name": "DefaultFailureHandler",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "DefaultFailureHandler",
            "id": "DefaultFailureHandler0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "name": "fail",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "reason",
                "id": "reason"
              }
            ],
            "id": "fail1()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "name": "failMatch",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "actual",
                "id": "actual"
              },
              {
                "ref": {
                  "name": "Matcher",
                  "refId": "Matcher"
                },
                "kind": "param",
                "name": "matcher",
                "id": "matcher"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "reason",
                "id": "reason"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "verbose",
                "id": "verbose"
              }
            ],
            "id": "failMatch5()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "DefaultFailureHandler",
            "id": "DefaultFailureHandler0()"
          }
        ],
        "id": "DefaultFailureHandler"
      },
      {
        "interfaces": [
          {
            "name": "Description",
            "refId": "Description"
          }
        ],
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "name": "StringDescription",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "Initialize the description with initial contents [init]. ",
            "name": "StringDescription",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "init",
                "id": "init"
              }
            ],
            "id": "StringDescription1()"
          },
          {
            "returnType": {
              "name": "String",
              "refId": "String"
            },
            "kind": "method",
            "comment": "Get the description as a string. ",
            "name": "toString",
            "id": "toString0()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "Append some plain [text] to the description.  ",
            "name": "add",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "text",
                "id": "text"
              }
            ],
            "id": "add1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "Change the value of the description. ",
            "name": "replace",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "text",
                "id": "text"
              }
            ],
            "id": "replace1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "\nAppends a description of [value]. If it is an IMatcher use its\ndescribe method; if it is a string use its literal value after\nescaping any embedded control characters; otherwise use its\ntoString() value and wrap it in angular \"quotes\".\n",
            "name": "addDescriptionOf",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "addDescriptionOf1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "\nAppend an [Iterable] [list] of objects to the description, using the\nspecified [separator] and framing the list with [start]\nand [end].\n",
            "name": "addAll",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "start",
                "id": "start"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "separator",
                "id": "separator"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "end",
                "id": "end"
              },
              {
                "ref": {
                  "name": "Iterable",
                  "refId": "Iterable"
                },
                "kind": "param",
                "name": "list",
                "id": "list"
              }
            ],
            "id": "addAll4()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "Escape the control characters in [string] so that they are visible. ",
            "name": "_addEscapedString",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "string",
                "id": "string"
              }
            ],
            "id": "_addEscapedString1()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "Return the escaped form of a character [ch]. ",
            "name": "_escape",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "ch",
                "id": "ch"
              }
            ],
            "id": "_escape1()"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "property",
            "name": "_out",
            "id": "_out"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "comment": "Initialize the description with initial contents [init]. ",
            "name": "StringDescription",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "init",
                "id": "init"
              }
            ],
            "id": "StringDescription1()"
          }
        ],
        "id": "StringDescription"
      },
      {
        "superclass": {
          "name": "BaseMatcher",
          "refId": "BaseMatcher"
        },
        "kind": "class",
        "comment": "\nA useful utility class for implementing other matchers through inheritance.\nDerived classes should call the base constructor with a feature name and\ndescription, and an instance matcher, and should implement the\n[featureValueOf] abstract method.\n\nThe feature description will typically describe the item and the feature,\nwhile the feature name will just name the feature. For example, we may\nhave a Widget class where each Widget has a price; we could make a\nFeatureMatcher that can make assertions about prices with:\n\n    class HasPrice extends FeatureMatcher {\n      const HasPrice(matcher) :\n          super(\"Widget with price that is\", \"price\", matcher);\n      featureValueOf(actual) => actual.price;\n    }\n\nand then use this for example like:\n\n     expect(inventoryItem, new HasPrice(greaterThan(0)));\n",
        "name": "CustomMatcher",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "CustomMatcher",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "_featureDescription",
                "id": "_featureDescription"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "_featureName",
                "id": "_featureName"
              },
              {
                "ref": {
                  "name": "Matcher",
                  "refId": "Matcher"
                },
                "kind": "param",
                "name": "_matcher",
                "id": "_matcher"
              }
            ],
            "id": "CustomMatcher3()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "Override this to extract the interesting feature.",
            "name": "featureValueOf",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "actual",
                "id": "actual"
              }
            ],
            "id": "featureValueOf1()"
          },
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "name": "matches",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "item",
                "id": "item"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              }
            ],
            "id": "matches2()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "name": "describe",
            "children": [
              {
                "ref": {
                  "name": "Description",
                  "refId": "Description"
                },
                "kind": "param",
                "name": "description",
                "id": "description"
              }
            ],
            "id": "describe1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "name": "describeMismatch",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "item",
                "id": "item"
              },
              {
                "ref": {
                  "name": "Description",
                  "refId": "Description"
                },
                "kind": "param",
                "name": "mismatchDescription",
                "id": "mismatchDescription"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "verbose",
                "id": "verbose"
              }
            ],
            "id": "describeMismatch4()"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "_featureDescription",
            "id": "_featureDescription"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "_featureName",
            "id": "_featureName"
          },
          {
            "ref": {
              "name": "Matcher",
              "refId": "Matcher"
            },
            "kind": "property",
            "name": "_matcher",
            "id": "_matcher"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "CustomMatcher",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "_featureDescription",
                "id": "_featureDescription"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "_featureName",
                "id": "_featureName"
              },
              {
                "ref": {
                  "name": "Matcher",
                  "refId": "Matcher"
                },
                "kind": "param",
                "name": "_matcher",
                "id": "_matcher"
              }
            ],
            "id": "CustomMatcher3()"
          }
        ],
        "id": "CustomMatcher"
      },
      {
        "superclass": {
          "name": "BaseMatcher",
          "refId": "BaseMatcher"
        },
        "kind": "class",
        "name": "TypeMatcher",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "TypeMatcher",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "_name",
                "id": "_name"
              }
            ],
            "id": "TypeMatcher1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "name": "describe",
            "children": [
              {
                "ref": {
                  "name": "Description",
                  "refId": "Description"
                },
                "kind": "param",
                "name": "description",
                "id": "description"
              }
            ],
            "id": "describe1()"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "_name",
            "id": "_name"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "TypeMatcher",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "_name",
                "id": "_name"
              }
            ],
            "id": "TypeMatcher1()"
          }
        ],
        "id": "TypeMatcher"
      },
      {
        "superclass": {
          "name": "BaseMatcher",
          "refId": "BaseMatcher"
        },
        "kind": "class",
        "name": "Throws",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "Throws",
            "children": [
              {
                "ref": {
                  "name": "Matcher",
                  "refId": "Matcher"
                },
                "isOptional": true,
                "kind": "param",
                "name": "matcher",
                "id": "matcher"
              }
            ],
            "id": "Throws1()"
          },
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "name": "matches",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "item",
                "id": "item"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              }
            ],
            "id": "matches2()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "name": "describe",
            "children": [
              {
                "ref": {
                  "name": "Description",
                  "refId": "Description"
                },
                "kind": "param",
                "name": "description",
                "id": "description"
              }
            ],
            "id": "describe1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "name": "describeMismatch",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "item",
                "id": "item"
              },
              {
                "ref": {
                  "name": "Description",
                  "refId": "Description"
                },
                "kind": "param",
                "name": "mismatchDescription",
                "id": "mismatchDescription"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "verbose",
                "id": "verbose"
              }
            ],
            "id": "describeMismatch4()"
          },
          {
            "ref": {
              "name": "Matcher",
              "refId": "Matcher"
            },
            "kind": "property",
            "name": "_matcher",
            "id": "_matcher"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "Throws",
            "children": [
              {
                "ref": {
                  "name": "Matcher",
                  "refId": "Matcher"
                },
                "isOptional": true,
                "kind": "param",
                "name": "matcher",
                "id": "matcher"
              }
            ],
            "id": "Throws1()"
          }
        ],
        "id": "Throws"
      },
      {
        "superclass": {
          "name": "BaseMatcher",
          "refId": "BaseMatcher"
        },
        "kind": "class",
        "comment": "\nReturns a matcher that matches if an object is an instance\nof [type] (or a subtype).\n\nAs types are not first class objects in Dart we can only\napproximate this test by using a generic wrapper class.\n\nFor example, to test whether 'bar' is an instance of type\n'Foo', we would write:\n\n    expect(bar, new isInstanceOf<Foo>());\n\nTo get better error message, supply a name when creating the\nType wrapper; e.g.:\n\n    expect(bar, new isInstanceOf<Foo>('Foo'));\n\nNote that this does not currently work in dart2js; it will\nmatch any type, and isNot(new isInstanceof<T>()) will always\nfail. This is because dart2js currently ignores template type\nparameters.\n",
        "name": "isInstanceOf",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "isInstanceOf",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "name",
                "id": "name"
              }
            ],
            "id": "isInstanceOf1()"
          },
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "name": "matches",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "obj",
                "id": "obj"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              }
            ],
            "id": "matches2()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "name": "describe",
            "children": [
              {
                "ref": {
                  "name": "Description",
                  "refId": "Description"
                },
                "kind": "param",
                "name": "description",
                "id": "description"
              }
            ],
            "id": "describe1()"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "_name",
            "id": "_name"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "isInstanceOf",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "name",
                "id": "name"
              }
            ],
            "id": "isInstanceOf1()"
          }
        ],
        "id": "isInstanceOf"
      },
      {
        "interfaces": [
          {
            "name": "Matcher",
            "refId": "Matcher"
          }
        ],
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nBaseMatcher is the base class for all matchers. To implement a new\nmatcher, either add a class that implements from IMatcher or\na class that inherits from Matcher. Inheriting from Matcher has\nthe benefit that a default implementation of describeMismatch will\nbe provided.\n",
        "name": "BaseMatcher",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "BaseMatcher",
            "id": "BaseMatcher0()"
          },
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "comment": "\nTests the matcher against a given [item]\nand return true if the match succeeds; false otherwise.\n[matchState] may be used to return additional info for\nthe use of [describeMismatch].\n",
            "name": "matches",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "item",
                "id": "item"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              }
            ],
            "id": "matches2()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "\nCreates a textual description of a matcher,\nby appending to [mismatchDescription].\n",
            "name": "describe",
            "children": [
              {
                "ref": {
                  "name": "Description",
                  "refId": "Description"
                },
                "kind": "param",
                "name": "mismatchDescription",
                "id": "mismatchDescription"
              }
            ],
            "id": "describe1()"
          },
          {
            "returnType": {
              "name": "Description",
              "refId": "Description"
            },
            "kind": "method",
            "comment": "\nGenerates a description of the matcher failed for a particular\n[item], by appending the description to [mismatchDescription].\nIt does not check whether the [item] fails the match, as it is\nonly called after a failed match. There may be additional info\nabout the mismatch in [matchState].\n",
            "name": "describeMismatch",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "item",
                "id": "item"
              },
              {
                "ref": {
                  "name": "Description",
                  "refId": "Description"
                },
                "kind": "param",
                "name": "mismatchDescription",
                "id": "mismatchDescription"
              },
              {
                "ref": {
                  "name": "MatchState",
                  "refId": "MatchState"
                },
                "kind": "param",
                "name": "matchState",
                "id": "matchState"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "verbose",
                "id": "verbose"
              }
            ],
            "id": "describeMismatch4()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "BaseMatcher",
            "id": "BaseMatcher0()"
          }
        ],
        "id": "BaseMatcher"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nMatchState is a simple wrapper around an arbitrary object.\n[Matcher] [matches] methods can use this to store useful\ninformation upon match failures, and this information will\nbe passed to [describeMismatch]. Each [Matcher] is responsible\nfor its own use of this state, so the state created by [matches]\nshould be consistent with that expected by [describeMismatch] in\nthe same [Matcher] class, but can vary between classes. The inner\nstate, if set, will typically be a [Map] with a number of key-value\npairs containing relevant state information.\n",
        "name": "MatchState",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "MatchState",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "state",
                "id": "state"
              }
            ],
            "id": "MatchState1()"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "property",
            "name": "state",
            "id": "state"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "MatchState",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "state",
                "id": "state"
              }
            ],
            "id": "MatchState1()"
          }
        ],
        "id": "MatchState"
      }
    ],
    "id": "file:///Users/mhennessy/dart/sudoku/packages/unittest/matcher.dart"
  },
  {
    "kind": "library",
    "name": "metadata",
    "children": [
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "Metadata that specifies that that member is editable through generated\nfiles.",
        "name": "DocsEditable",
        "id": "DocsEditable"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nMetadata that specifies the DOM name associated with the element.\n\nThis is used for API generation.\n\n[name] should be formatted as `interface.member`.\n",
        "name": "DomName",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "DomName",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "name",
                "id": "name"
              }
            ],
            "id": "DomName1()"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "name",
            "id": "name"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "DomName",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "name",
                "id": "name"
              }
            ],
            "id": "DomName1()"
          }
        ],
        "id": "DomName"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nAn annotation used to mark an API as being experimental.\n\nAn API is considered to be experimental if it is still going through the\nprocess of stabilizing and is subject to change or removal.\n\nSee also:\n\n* [W3C recommendation](http://en.wikipedia.org/wiki/W3C_recommendation)\n",
        "name": "Experimental",
        "id": "Experimental"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nAn annotation used to mark a feature as only being supported by a subset\nof the browsers that Dart supports by default.\n\nIf an API is not annotated with [SupportedBrowser] then it is assumed to\nwork on all browsers Dart supports.\n",
        "name": "SupportedBrowser",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "SupportedBrowser",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "browserName",
                "id": "browserName"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "minimumVersion",
                "id": "minimumVersion"
              }
            ],
            "id": "SupportedBrowser2()"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "isStatic": true,
            "kind": "property",
            "name": "CHROME",
            "id": "CHROME"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "isStatic": true,
            "kind": "property",
            "name": "FIREFOX",
            "id": "FIREFOX"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "isStatic": true,
            "kind": "property",
            "name": "IE",
            "id": "IE"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "isStatic": true,
            "kind": "property",
            "name": "OPERA",
            "id": "OPERA"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "isStatic": true,
            "kind": "property",
            "name": "SAFARI",
            "id": "SAFARI"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "browserName",
            "id": "browserName"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "minimumVersion",
            "id": "minimumVersion"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "SupportedBrowser",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "browserName",
                "id": "browserName"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "minimumVersion",
                "id": "minimumVersion"
              }
            ],
            "id": "SupportedBrowser2()"
          }
        ],
        "id": "SupportedBrowser"
      }
    ],
    "id": "file:///Users/mhennessy/apps/dart/dart-sdk/lib/html/html_common/metadata.dart"
  },
  {
    "kind": "library",
    "comment": "\nA simple mocking/spy library.\n\nTo create a mock objects for some class T, create a new class using:\n\n    class MockT extends Mock implements T {};\n\nThen specify the [Behavior] of the Mock for different methods using\n[when] (to select the method and parameters) and then the [Action]s\nfor the [Behavior] by calling [thenReturn], [alwaysReturn], [thenThrow],\n[alwaysThrow], [thenCall] or [alwaysCall].\n\n[thenReturn], [thenThrow] and [thenCall] are one-shot so you would\ntypically call these more than once to specify a sequence of actions;\nthis can be done with chained calls, e.g.:\n\n     m.when(callsTo('foo')).\n         thenReturn(0).thenReturn(1).thenReturn(2);\n\n[thenCall] and [alwaysCall] allow you to proxy mocked methods, chaining\nto some other implementation. This provides a way to implement 'spies'.\n\nYou can disable logging for a particular [Behavior] easily:\n\n    m.when(callsTo('bar')).logging = false;\n\nYou can then use the mock object. Once you are done, to verify the\nbehavior, use [getLogs] to extract a relevant subset of method call\nlogs and apply [Matchers] to these through calling [verify].\n\nA Mock can be given a name when constructed. In this case instead of\nkeeping its own log, it uses a shared log. This can be useful to get an\naudit trail of interleaved behavior. It is the responsibility of the user\nto ensure that mock names, if used, are unique.\n\nLimitations:\n\n* only positional parameters are supported (up to 10);\n* to mock getters you will need to include parentheses in the call\n      (e.g. m.length() will work but not m.length).\n\nHere is a simple example:\n\n    class MockList extends Mock implements List {};\n\n    List m = new MockList();\n    m.when(callsTo('add', anything)).alwaysReturn(0);\n\n    m.add('foo');\n    m.add('bar');\n\n    getLogs(m, callsTo('add', anything)).verify(happenedExactly(2));\n    getLogs(m, callsTo('add', 'foo')).verify(happenedOnce);\n    getLogs(m, callsTo('add', 'isNull)).verify(neverHappened);\n\nNote that we don't need to provide argument matchers for all arguments,\nbut we do need to provide arguments for all matchers. So this is allowed:\n\n    m.when(callsTo('add')).alwaysReturn(0);\n    m.add(1, 2);\n\nBut this is not allowed and will throw an exception:\n\n    m.when(callsTo('add', anything, anything)).alwaysReturn(0);\n    m.add(1);\n\nHere is a way to implement a 'spy', which is where we log the call\nbut then hand it off to some other function, which is the same\nmethod in a real instance of the class being mocked:\n\n    class Foo {\n      bar(a, b, c) => a + b + c;\n    }\n\n    class MockFoo extends Mock implements Foo {\n      Foo real;\n      MockFoo() {\n        real = new Foo();\n        this.when(callsTo('bar')).alwaysCall(real.bar);\n      }\n    }\n\n",
    "name": "mock",
    "children": [
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\n[neverThrew] asserts that no matching call to a method threw\na value that matched [value].\n",
        "name": "neverThrew",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "neverThrew1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\n[sometimeThrew] asserts that at least one matching call to a method threw\na value that matched [value].\n",
        "name": "sometimeThrew",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "sometimeThrew1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\n[alwaysThrew] asserts that all matching calls to a method threw\na value that matched [value].\n",
        "name": "alwaysThrew",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "alwaysThrew1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\n[neverReturned] asserts that no matching calls to a method returned\na value that matched [value].\n",
        "name": "neverReturned",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "neverReturned1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\n[sometimeReturned] asserts that at least one matching call to a method\nreturned a value that matched [value].\n",
        "name": "sometimeReturned",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "sometimeReturned1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\n[alwaysReturned] asserts that all matching calls to a method returned\na value that matched [value].\n",
        "name": "alwaysReturned",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "alwaysReturned1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\n[throwing] matches log entrues where the call to a method threw\na value that matched [value].\n",
        "name": "throwing",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "throwing1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "\n[returning] matches log entries where the call to a method returned\na value that matched [value].\n",
        "name": "returning",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "value",
            "id": "value"
          }
        ],
        "id": "returning1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "[happenedAtMost] matches a maximum number of calls. ",
        "name": "happenedAtMost",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "count",
            "id": "count"
          }
        ],
        "id": "happenedAtMost1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "[happenedAtLeast] matches a minimum number of calls. ",
        "name": "happenedAtLeast",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "count",
            "id": "count"
          }
        ],
        "id": "happenedAtLeast1()"
      },
      {
        "returnType": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "method",
        "comment": "[happenedExactly] matches an exact number of calls. ",
        "name": "happenedExactly",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "count",
            "id": "count"
          }
        ],
        "id": "happenedExactly1()"
      },
      {
        "returnType": {
          "name": "String",
          "refId": "String"
        },
        "kind": "method",
        "comment": "Utility function for optionally qualified method names ",
        "name": "_qualifiedName",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "owner",
            "id": "owner"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "method",
            "id": "method"
          }
        ],
        "id": "_qualifiedName2()"
      },
      {
        "returnType": {
          "name": "CallMatcher",
          "refId": "CallMatcher"
        },
        "kind": "method",
        "comment": "\nReturns a [CallMatcher] for the specified signature. [method] can be\nnull to match anything, or a literal [String], a predicate [Function],\nor a [Matcher]. The various arguments can be scalar values or [Matcher]s.\n",
        "name": "callsTo",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "method",
            "id": "method"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg0",
            "id": "arg0"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg1",
            "id": "arg1"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg2",
            "id": "arg2"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg3",
            "id": "arg3"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg4",
            "id": "arg4"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg5",
            "id": "arg5"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg6",
            "id": "arg6"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg7",
            "id": "arg7"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg8",
            "id": "arg8"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "arg9",
            "id": "arg9"
          }
        ],
        "id": "callsTo11()"
      },
      {
        "returnType": {
          "name": "String",
          "refId": "String"
        },
        "kind": "method",
        "comment": "\nThe error formatter for mocking is a bit different from the default one\nfor unit testing; instead of the third argument being a 'reason'\nit is instead a [signature] describing the method signature filter\nthat was used to select the logs that were verified.\n",
        "name": "_mockingErrorFormatter",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "actual",
            "id": "actual"
          },
          {
            "ref": {
              "name": "Matcher",
              "refId": "Matcher"
            },
            "kind": "param",
            "name": "matcher",
            "id": "matcher"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "signature",
            "id": "signature"
          },
          {
            "ref": {
              "name": "MatchState",
              "refId": "MatchState"
            },
            "kind": "param",
            "name": "matchState",
            "id": "matchState"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "param",
            "name": "verbose",
            "id": "verbose"
          }
        ],
        "id": "_mockingErrorFormatter5()"
      },
      {
        "ref": {
          "name": "LogEntryList",
          "refId": "LogEntryList"
        },
        "kind": "property",
        "name": "sharedLog",
        "id": "sharedLog"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "happenedAtMostOnce",
        "id": "happenedAtMostOnce"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "happenedAtLeastOnce",
        "id": "happenedAtLeastOnce"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "happenedOnce",
        "id": "happenedOnce"
      },
      {
        "ref": {
          "name": "Matcher",
          "refId": "Matcher"
        },
        "kind": "property",
        "name": "neverHappened",
        "id": "neverHappened"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "_noArg",
        "id": "_noArg"
      },
      {
        "ref": {
          "name": "_MockFailureHandler",
          "refId": "_MockFailureHandler"
        },
        "kind": "property",
        "name": "_mockFailureHandler",
        "id": "_mockFailureHandler"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "The base class for all mocked objects. ",
        "name": "Mock",
        "children": [
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "name": "logging",
            "id": "logging0()"
          },
          {
            "isSetter": true,
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "logging=",
            "children": [
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "logging=1()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "\nDefault constructor. Unknown method calls are allowed and logged,\nthe mock has no name, and has its own log.\n",
            "name": "Mock",
            "id": "Mock0()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "\nThis constructor makes a mock that has a [name] and possibly uses\na shared [log]. If [throwIfNoBehavior] is true, any calls to methods\nthat have no defined behaviors will throw an exception; otherwise they\nwill be allowed and logged (but will not do anything).\nIf [enableLogging] is false, no logging will be done initially (whether\nor not a [log] is supplied), but [logging] can be set to true later.\n",
            "name": "Mock.custom",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "name",
                "id": "name"
              },
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "isOptional": true,
                "kind": "param",
                "name": "log",
                "id": "log"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "throwIfNoBehavior",
                "id": "throwIfNoBehavior"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "enableLogging",
                "id": "enableLogging"
              }
            ],
            "id": "Mock.custom4()"
          },
          {
            "returnType": {
              "name": "Behavior",
              "refId": "Behavior"
            },
            "kind": "method",
            "comment": "\n[when] is used to create a new or extend an existing [Behavior].\nA [CallMatcher] [filter] must be supplied, and the [Behavior]s for\nthat signature are returned (being created first if needed).\n\nTypical use case:\n\n    mock.when(callsTo(...)).alwaysReturn(...);\n",
            "name": "when",
            "children": [
              {
                "ref": {
                  "name": "CallMatcher",
                  "refId": "CallMatcher"
                },
                "kind": "param",
                "name": "logFilter",
                "id": "logFilter"
              }
            ],
            "id": "when1()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "\nThis is the handler for method calls. We loop through the list\nof [Behavior]s, and find the first match that still has return\nvalues available, and then do the action specified by that\nreturn value. If we find no [Behavior] to apply an exception is\nthrown.\n",
            "name": "noSuchMethod",
            "children": [
              {
                "ref": {
                  "name": "InvocationMirror",
                  "refId": "InvocationMirror"
                },
                "kind": "param",
                "name": "invocation",
                "id": "invocation"
              }
            ],
            "id": "noSuchMethod1()"
          },
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "comment": "[verifyZeroInteractions] returns true if no calls were made ",
            "name": "verifyZeroInteractions",
            "id": "verifyZeroInteractions0()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\n[getLogs] extracts all calls from the call log that match the\n[logFilter], and returns the matching list of [LogEntry]s. If\n[destructive] is false (the default) the matching calls are left\nin the log, else they are removed. Removal allows us to verify a\nset of interactions and then verify that there are no other\ninteractions left. [actionMatcher] can be used to further\nrestrict the returned logs based on the action the mock performed.\n[logFilter] can be a [CallMatcher] or a predicate function that\ntakes a [LogEntry] and returns a bool.\n\nTypical usage:\n\n    getLogs(callsTo(...)).verify(...);\n",
            "name": "getLogs",
            "children": [
              {
                "ref": {
                  "name": "CallMatcher",
                  "refId": "CallMatcher"
                },
                "isOptional": true,
                "kind": "param",
                "name": "logFilter",
                "id": "logFilter"
              },
              {
                "ref": {
                  "name": "Matcher",
                  "refId": "Matcher"
                },
                "isOptional": true,
                "kind": "param",
                "name": "actionMatcher",
                "id": "actionMatcher"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "destructive",
                "id": "destructive"
              }
            ],
            "id": "getLogs3()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nUseful shorthand method that creates a [CallMatcher] from its arguments\nand then calls [getLogs].\n",
            "name": "calls",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "method",
                "id": "method"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg0",
                "id": "arg0"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg1",
                "id": "arg1"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg2",
                "id": "arg2"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg3",
                "id": "arg3"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg4",
                "id": "arg4"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg5",
                "id": "arg5"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg6",
                "id": "arg6"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg7",
                "id": "arg7"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg8",
                "id": "arg8"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg9",
                "id": "arg9"
              }
            ],
            "id": "calls11()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "Clear the behaviors for the Mock. ",
            "name": "resetBehavior",
            "id": "resetBehavior0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "Clear the logs for the Mock. ",
            "name": "clearLogs",
            "id": "clearLogs0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "Clear both logs and behavior. ",
            "name": "reset",
            "id": "reset0()"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "property",
            "name": "logging",
            "id": "logging"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "name",
            "id": "name"
          },
          {
            "ref": {
              "name": "Map",
              "refId": "Map",
              "arguments": [
                {
                  "name": "String",
                  "refId": "String"
                },
                {
                  "name": "Behavior",
                  "refId": "Behavior"
                }
              ]
            },
            "kind": "property",
            "name": "_behaviors",
            "id": "_behaviors"
          },
          {
            "ref": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "property",
            "name": "log",
            "id": "log"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "property",
            "name": "_throwIfNoBehavior",
            "id": "_throwIfNoBehavior"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "property",
            "name": "_logging",
            "id": "_logging"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "comment": "\nDefault constructor. Unknown method calls are allowed and logged,\nthe mock has no name, and has its own log.\n",
            "name": "Mock",
            "id": "Mock0()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "comment": "\nThis constructor makes a mock that has a [name] and possibly uses\na shared [log]. If [throwIfNoBehavior] is true, any calls to methods\nthat have no defined behaviors will throw an exception; otherwise they\nwill be allowed and logged (but will not do anything).\nIf [enableLogging] is false, no logging will be done initially (whether\nor not a [log] is supplied), but [logging] can be set to true later.\n",
            "name": "Mock.custom",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "name",
                "id": "name"
              },
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "isOptional": true,
                "kind": "param",
                "name": "log",
                "id": "log"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "throwIfNoBehavior",
                "id": "throwIfNoBehavior"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "enableLogging",
                "id": "enableLogging"
              }
            ],
            "id": "Mock.custom4()"
          }
        ],
        "id": "Mock"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nWe do verification on a list of [LogEntry]s. To allow chaining\nof calls to verify, we encapsulate such a list in the [LogEntryList]\nclass.\n",
        "name": "LogEntryList",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "LogEntryList",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "filter",
                "id": "filter"
              }
            ],
            "id": "LogEntryList1()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "Add a [LogEntry] to the log. ",
            "name": "add",
            "children": [
              {
                "ref": {
                  "name": "LogEntry",
                  "refId": "LogEntry"
                },
                "kind": "param",
                "name": "entry",
                "id": "entry"
              }
            ],
            "id": "add1()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "Get the first entry, or null if no entries. ",
            "name": "first",
            "id": "first0()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "Get the last entry, or null if no entries. ",
            "name": "last",
            "id": "last0()"
          },
          {
            "returnType": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "method",
            "comment": "Creates a LogEntry predicate function from the argument. ",
            "name": "_makePredicate",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "arg",
                "id": "arg"
              }
            ],
            "id": "_makePredicate1()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nCreate a new [LogEntryList] consisting of [LogEntry]s from\nthis list that match the specified [mockNameFilter] and [logFilter].\n[mockNameFilter] can be null, a [String], a predicate [Function],\nor a [Matcher]. If [mockNameFilter] is null, this is the same as\n[anything].\nIf [logFilter] is null, all entries in the log will be returned.\nOtherwise [logFilter] should be a [CallMatcher] or  predicate function\nthat takes a [LogEntry] and returns a bool.\nIf [destructive] is true, the log entries are removed from the\noriginal list.\n",
            "name": "getMatches",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "mockNameFilter",
                "id": "mockNameFilter"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "logFilter",
                "id": "logFilter"
              },
              {
                "ref": {
                  "name": "Matcher",
                  "refId": "Matcher"
                },
                "isOptional": true,
                "kind": "param",
                "name": "actionMatcher",
                "id": "actionMatcher"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "destructive",
                "id": "destructive"
              }
            ],
            "id": "getMatches4()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "Apply a unit test [Matcher] to the [LogEntryList]. ",
            "name": "verify",
            "children": [
              {
                "ref": {
                  "name": "Matcher",
                  "refId": "Matcher"
                },
                "kind": "param",
                "name": "matcher",
                "id": "matcher"
              }
            ],
            "id": "verify1()"
          },
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "comment": "\nIterate through the list and call the [validator] function with the\nlog [List] and position. The [validator] should return the number of\npositions to advance upon success, or zero upon failure. When zero is\nreturned an error is reported. [reason] can be used to provide a\nmore descriptive failure message. If a failure occurred false will be\nreturned (unless the failure handler itself threw an exception);\notherwise true is returned.\nThe use case here is to perform more complex validations; for example\nwe may want to assert that the return value from some function is\nlater used as a parameter to a following function. If we filter the logs\nto include just these two functions we can write a simple validator to\ndo this check.\n",
            "name": "stepwiseValidate",
            "children": [
              {
                "ref": {
                  "name": "StepValidator",
                  "refId": "StepValidator"
                },
                "kind": "param",
                "name": "validator",
                "id": "validator"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "reason",
                "id": "reason"
              }
            ],
            "id": "stepwiseValidate2()"
          },
          {
            "returnType": {
              "name": "String",
              "refId": "String"
            },
            "kind": "method",
            "comment": "\nTurn the logs into human-readable text. If [baseTime] is specified\nthen each entry is prefixed with the offset from that time in\nmilliseconds; otherwise the time of day is used.\n",
            "name": "toString",
            "children": [
              {
                "ref": {
                  "name": "DateTime",
                  "refId": "DateTime"
                },
                "isOptional": true,
                "kind": "param",
                "name": "baseTime",
                "id": "baseTime"
              }
            ],
            "id": "toString1()"
          },
          {
            "returnType": {
              "name": "int",
              "refId": "int"
            },
            "kind": "method",
            "comment": "\n Find the first log entry that satisfies [logFilter] and\n return its position. A search [start] position can be provided\n to allow for repeated searches. [logFilter] can be a [CallMatcher],\n or a predicate function that takes a [LogEntry] argument and returns\n a bool. If [logFilter] is null, it will match any [LogEntry].\n If no entry is found, then [failureReturnValue] is returned.\n After each check the position is updated by [skip], so using\n [skip] of -1 allows backward searches, using a [skip] of 2 can\n be used to check pairs of adjacent entries, and so on.\n",
            "name": "findLogEntry",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "logFilter",
                "id": "logFilter"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "isOptional": true,
                "kind": "param",
                "name": "start",
                "id": "start"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "isOptional": true,
                "kind": "param",
                "name": "failureReturnValue",
                "id": "failureReturnValue"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "skip",
                "id": "skip"
              }
            ],
            "id": "findLogEntry4()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened up to the first one that\nsatisfies [logFilter]. If [inPlace] is true, then returns\nthis LogEntryList after removing the from the first satisfier;\nonwards otherwise a new list is created. [description]\nis used to create a new name for the resulting list.\n[defaultPosition] is used as the index of the matching item in\nthe case that no match is found.\n",
            "name": "_head",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "logFilter",
                "id": "logFilter"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "description",
                "id": "description"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "defaultPosition",
                "id": "defaultPosition"
              }
            ],
            "id": "_head4()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened from the first one that\nsatisfies [logFilter]. If [inPlace] is true, then returns\nthis LogEntryList after removing the entries up to the first\nsatisfier; otherwise a new list is created. [description]\nis used to create a new name for the resulting list.\n[defaultPosition] is used as the index of the matching item in\nthe case that no match is found.\n",
            "name": "_tail",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "logFilter",
                "id": "logFilter"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "description",
                "id": "description"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "defaultPosition",
                "id": "defaultPosition"
              }
            ],
            "id": "_tail4()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened after [when]. If [inPlace]\nis true, then it returns this LogEntryList after removing\nthe entries that happened up to [when]; otherwise a new\nlist is created.\n",
            "name": "after",
            "children": [
              {
                "ref": {
                  "name": "DateTime",
                  "refId": "DateTime"
                },
                "kind": "param",
                "name": "when",
                "id": "when"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "after2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened from [when] onwards. If\n[inPlace] is true, then it returns this LogEntryList after\nremoving the entries that happened before [when]; otherwise\na new list is created.\n",
            "name": "from",
            "children": [
              {
                "ref": {
                  "name": "DateTime",
                  "refId": "DateTime"
                },
                "kind": "param",
                "name": "when",
                "id": "when"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "from2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened until [when]. If [inPlace]\nis true, then it returns this LogEntryList after removing\nthe entries that happened after [when]; otherwise a new\nlist is created.\n",
            "name": "until",
            "children": [
              {
                "ref": {
                  "name": "DateTime",
                  "refId": "DateTime"
                },
                "kind": "param",
                "name": "when",
                "id": "when"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "until2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened before [when]. If [inPlace]\nis true, then it returns this LogEntryList after removing\nthe entries that happened from [when] onwards; otherwise a new\nlist is created.\n",
            "name": "before",
            "children": [
              {
                "ref": {
                  "name": "DateTime",
                  "refId": "DateTime"
                },
                "kind": "param",
                "name": "when",
                "id": "when"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "before2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened after [logEntry]'s time.\nIf [inPlace] is true, then it returns this LogEntryList after\nremoving the entries that happened up to [when]; otherwise a new\nlist is created. If [logEntry] is null the current time is used.\n",
            "name": "afterEntry",
            "children": [
              {
                "ref": {
                  "name": "LogEntry",
                  "refId": "LogEntry"
                },
                "kind": "param",
                "name": "logEntry",
                "id": "logEntry"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "afterEntry2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened from [logEntry]'s time onwards.\nIf [inPlace] is true, then it returns this LogEntryList after\nremoving the entries that happened before [when]; otherwise\na new list is created. If [logEntry] is null the current time is used.\n",
            "name": "fromEntry",
            "children": [
              {
                "ref": {
                  "name": "LogEntry",
                  "refId": "LogEntry"
                },
                "kind": "param",
                "name": "logEntry",
                "id": "logEntry"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "fromEntry2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened until [logEntry]'s time. If\n[inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened after [when]; otherwise a new\nlist is created. If [logEntry] is null the epoch time is used.\n",
            "name": "untilEntry",
            "children": [
              {
                "ref": {
                  "name": "LogEntry",
                  "refId": "LogEntry"
                },
                "kind": "param",
                "name": "logEntry",
                "id": "logEntry"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "untilEntry2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened before [logEntry]'s time. If\n[inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened from [when] onwards; otherwise a new\nlist is created. If [logEntry] is null the epoch time is used.\n",
            "name": "beforeEntry",
            "children": [
              {
                "ref": {
                  "name": "LogEntry",
                  "refId": "LogEntry"
                },
                "kind": "param",
                "name": "logEntry",
                "id": "logEntry"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "beforeEntry2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened after the first event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened earlier; otherwise a new list is created.\n",
            "name": "afterFirst",
            "children": [
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "segment",
                "id": "segment"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "afterFirst2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened after the last event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened earlier; otherwise a new list is created.\n",
            "name": "afterLast",
            "children": [
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "segment",
                "id": "segment"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "afterLast2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened from the time of the first event in\n[segment] onwards. If [inPlace] is true, then it returns this\nLogEntryList after removing the earlier entries; otherwise a new list\nis created.\n",
            "name": "fromFirst",
            "children": [
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "segment",
                "id": "segment"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "fromFirst2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened from the time of the last event in\n[segment] onwards. If [inPlace] is true, then it returns this\nLogEntryList after removing the earlier entries; otherwise a new list\nis created.\n",
            "name": "fromLast",
            "children": [
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "segment",
                "id": "segment"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "fromLast2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened until the first event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n",
            "name": "untilFirst",
            "children": [
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "segment",
                "id": "segment"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "untilFirst2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened until the last event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n",
            "name": "untilLast",
            "children": [
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "segment",
                "id": "segment"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "untilLast2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened before the first event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n",
            "name": "beforeFirst",
            "children": [
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "segment",
                "id": "segment"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "beforeFirst2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nReturns log events that happened before the last event in [segment].\nIf [inPlace] is true, then it returns this LogEntryList after removing\nthe entries that happened later; otherwise a new list is created.\n",
            "name": "beforeLast",
            "children": [
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "segment",
                "id": "segment"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "inPlace",
                "id": "inPlace"
              }
            ],
            "id": "beforeLast2()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nIterate through the LogEntryList looking for matches to the entries\nin [keys]; for each match found the closest [distance] neighboring log\nentries that match [mockNameFilter] and [logFilter] will be included in\nthe result. If [isPreceding] is true we use the neighbors that precede\nthe matched entry; else we use the neighbors that followed.\nIf [includeKeys] is true then the entries in [keys] that resulted in\nentries in the output list are themselves included in the output list. If\n[distance] is zero then all matches are included.\n",
            "name": "_neighboring",
            "children": [
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "isPreceding",
                "id": "isPreceding"
              },
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "keys",
                "id": "keys"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "mockNameFilter",
                "id": "mockNameFilter"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "logFilter",
                "id": "logFilter"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "distance",
                "id": "distance"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "includeKeys",
                "id": "includeKeys"
              }
            ],
            "id": "_neighboring6()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nIterate through the LogEntryList looking for matches to the entries\nin [keys]; for each match found the closest [distance] prior log entries\nthat match [mocknameFilter] and [logFilter] will be included in the result.\nIf [includeKeys] is true then the entries in [keys] that resulted in\nentries in the output list are themselves included in the output list. If\n[distance] is zero then all matches are included.\n\nThe idea here is that you could find log entries that are related to\nother logs entries in some temporal sense. For example, say we have a\nmethod commit() that returns -1 on failure. Before commit() gets called\nthe value being committed is created by process(). We may want to find\nthe calls to process() that preceded calls to commit() that failed.\nWe could do this with:\n\n     print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),\n         logFilter: callsTo('process')).toString());\n\nWe might want to include the details of the failing calls to commit()\nto see what parameters were passed in, in which case we would set\n[includeKeys].\n\nAs another simple example, say we wanted to know the three method\ncalls that immediately preceded each failing call to commit():\n\n    print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),\n        distance: 3).toString());\n",
            "name": "preceding",
            "children": [
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "keys",
                "id": "keys"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "mockNameFilter",
                "id": "mockNameFilter"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "logFilter",
                "id": "logFilter"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "isOptional": true,
                "kind": "param",
                "name": "distance",
                "id": "distance"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "includeKeys",
                "id": "includeKeys"
              }
            ],
            "id": "preceding5()"
          },
          {
            "returnType": {
              "name": "LogEntryList",
              "refId": "LogEntryList"
            },
            "kind": "method",
            "comment": "\nIterate through the LogEntryList looking for matches to the entries\nin [keys]; for each match found the closest [distance] subsequent log\nentries that match [mocknameFilter] and [logFilter] will be included in\nthe result. If [includeKeys] is true then the entries in [keys] that\nresulted in entries in the output list are themselves included in the\noutput list. If [distance] is zero then all matches are included.\nSee [preceding] for a usage example.\n",
            "name": "following",
            "children": [
              {
                "ref": {
                  "name": "LogEntryList",
                  "refId": "LogEntryList"
                },
                "kind": "param",
                "name": "keys",
                "id": "keys"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "mockNameFilter",
                "id": "mockNameFilter"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "logFilter",
                "id": "logFilter"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "isOptional": true,
                "kind": "param",
                "name": "distance",
                "id": "distance"
              },
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "isOptional": true,
                "kind": "param",
                "name": "includeKeys",
                "id": "includeKeys"
              }
            ],
            "id": "following5()"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "property",
            "comment": "Get the first entry, or null if no entries. ",
            "name": "first",
            "id": "first"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "property",
            "comment": "Get the last entry, or null if no entries. ",
            "name": "last",
            "id": "last"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "filter",
            "id": "filter"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "LogEntry",
                  "refId": "LogEntry"
                }
              ]
            },
            "kind": "property",
            "name": "logs",
            "id": "logs"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "LogEntryList",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "filter",
                "id": "filter"
              }
            ],
            "id": "LogEntryList1()"
          }
        ],
        "id": "LogEntryList"
      },
      {
        "kind": "typedef",
        "comment": "\n[StepValidator]s are used by [stepwiseValidate] in [LogEntryList], which\niterates through the list and call the [StepValidator] function with the\nlog [List] and position. The [StepValidator] should return the number of\npositions to advance upon success, or zero upon failure. When zero is\nreturned an error is reported.\n",
        "name": "StepValidator",
        "id": "StepValidator"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nEvery call to a [Mock] object method is logged. The logs are\nkept in instances of [LogEntry].\n",
        "name": "LogEntry",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "LogEntry",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "mockName",
                "id": "mockName"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "methodName",
                "id": "methodName"
              },
              {
                "ref": {
                  "name": "List",
                  "refId": "List"
                },
                "kind": "param",
                "name": "args",
                "id": "args"
              },
              {
                "ref": {
                  "name": "Action",
                  "refId": "Action"
                },
                "kind": "param",
                "name": "action",
                "id": "action"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "LogEntry5()"
          },
          {
            "returnType": {
              "name": "String",
              "refId": "String"
            },
            "kind": "method",
            "name": "_pad2",
            "children": [
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "val",
                "id": "val"
              }
            ],
            "id": "_pad21()"
          },
          {
            "returnType": {
              "name": "String",
              "refId": "String"
            },
            "kind": "method",
            "name": "toString",
            "children": [
              {
                "ref": {
                  "name": "DateTime",
                  "refId": "DateTime"
                },
                "isOptional": true,
                "kind": "param",
                "name": "baseTime",
                "id": "baseTime"
              }
            ],
            "id": "toString1()"
          },
          {
            "ref": {
              "name": "DateTime",
              "refId": "DateTime"
            },
            "kind": "property",
            "name": "time",
            "id": "time"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "mockName",
            "id": "mockName"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "methodName",
            "id": "methodName"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List"
            },
            "kind": "property",
            "name": "args",
            "id": "args"
          },
          {
            "ref": {
              "name": "Action",
              "refId": "Action"
            },
            "kind": "property",
            "name": "action",
            "id": "action"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "property",
            "name": "value",
            "id": "value"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "LogEntry",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "mockName",
                "id": "mockName"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "methodName",
                "id": "methodName"
              },
              {
                "ref": {
                  "name": "List",
                  "refId": "List"
                },
                "kind": "param",
                "name": "args",
                "id": "args"
              },
              {
                "ref": {
                  "name": "Action",
                  "refId": "Action"
                },
                "kind": "param",
                "name": "action",
                "id": "action"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "LogEntry5()"
          }
        ],
        "id": "LogEntry"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nA [Behavior] represents how a [Mock] will respond to one particular\ntype of method call.\n",
        "name": "Behavior",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "Behavior",
            "children": [
              {
                "ref": {
                  "name": "CallMatcher",
                  "refId": "CallMatcher"
                },
                "kind": "param",
                "name": "matcher",
                "id": "matcher"
              }
            ],
            "id": "Behavior1()"
          },
          {
            "returnType": {
              "name": "Behavior",
              "refId": "Behavior"
            },
            "kind": "method",
            "comment": "\nAdds a [Responder] that returns a [value] for [count] calls\n(1 by default).\n",
            "name": "thenReturn",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "count",
                "id": "count"
              }
            ],
            "id": "thenReturn2()"
          },
          {
            "returnType": {
              "name": "Behavior",
              "refId": "Behavior"
            },
            "kind": "method",
            "comment": "Adds a [Responder] that repeatedly returns a [value]. ",
            "name": "alwaysReturn",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "alwaysReturn1()"
          },
          {
            "returnType": {
              "name": "Behavior",
              "refId": "Behavior"
            },
            "kind": "method",
            "comment": "\nAdds a [Responder] that throws [value] [count]\ntimes (1 by default).\n",
            "name": "thenThrow",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "count",
                "id": "count"
              }
            ],
            "id": "thenThrow2()"
          },
          {
            "returnType": {
              "name": "Behavior",
              "refId": "Behavior"
            },
            "kind": "method",
            "comment": "Adds a [Responder] that throws [value] endlessly. ",
            "name": "alwaysThrow",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "alwaysThrow1()"
          },
          {
            "returnType": {
              "name": "Behavior",
              "refId": "Behavior"
            },
            "kind": "method",
            "comment": "\n[thenCall] creates a proxy Responder, that is called [count]\ntimes (1 by default; 0 is used for unlimited calls, and is\nexposed as [alwaysCall]). [value] is the function that will\nbe called with the same arguments that were passed to the\nmock. Proxies can be used to wrap real objects or to define\nmore complex return/throw behavior. You could even (if you\nwanted) use proxies to emulate the behavior of thenReturn;\ne.g.:\n\n    m.when(callsTo('foo')).thenReturn(0)\n\nis equivalent to:\n\n    m.when(callsTo('foo')).thenCall(() => 0)\n",
            "name": "thenCall",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "count",
                "id": "count"
              }
            ],
            "id": "thenCall2()"
          },
          {
            "returnType": {
              "name": "Behavior",
              "refId": "Behavior"
            },
            "kind": "method",
            "comment": "Creates a repeating proxy call. ",
            "name": "alwaysCall",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "alwaysCall1()"
          },
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "comment": "Returns true if a method call matches the [Behavior]. ",
            "name": "matches",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "method",
                "id": "method"
              },
              {
                "ref": {
                  "name": "List",
                  "refId": "List"
                },
                "kind": "param",
                "name": "args",
                "id": "args"
              }
            ],
            "id": "matches2()"
          },
          {
            "returnType": {
              "name": "String",
              "refId": "String"
            },
            "kind": "method",
            "comment": "Returns the [matcher]'s representation. ",
            "name": "toString",
            "id": "toString0()"
          },
          {
            "ref": {
              "name": "CallMatcher",
              "refId": "CallMatcher"
            },
            "kind": "property",
            "name": "matcher",
            "id": "matcher"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "Responder",
                  "refId": "Responder"
                }
              ]
            },
            "kind": "property",
            "name": "actions",
            "id": "actions"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "property",
            "name": "logging",
            "id": "logging"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "Behavior",
            "children": [
              {
                "ref": {
                  "name": "CallMatcher",
                  "refId": "CallMatcher"
                },
                "kind": "param",
                "name": "matcher",
                "id": "matcher"
              }
            ],
            "id": "Behavior1()"
          }
        ],
        "id": "Behavior"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nA [CallMatcher] is a special matcher used to match method calls (i.e.\na method name and set of arguments). It is not a [Matcher] like the\nunit test [Matcher], but instead represents a method name and a\ncollection of [Matcher]s, one per argument, that will be applied\nto the parameters to decide if the method call is a match.\n",
        "name": "CallMatcher",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "\nConstructor for [CallMatcher]. [name] can be null to\nmatch anything, or a literal [String], a predicate [Function],\nor a [Matcher]. The various arguments can be scalar values or\n[Matcher]s.\n",
            "name": "CallMatcher",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "name",
                "id": "name"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg0",
                "id": "arg0"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg1",
                "id": "arg1"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg2",
                "id": "arg2"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg3",
                "id": "arg3"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg4",
                "id": "arg4"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg5",
                "id": "arg5"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg6",
                "id": "arg6"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg7",
                "id": "arg7"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg8",
                "id": "arg8"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg9",
                "id": "arg9"
              }
            ],
            "id": "CallMatcher11()"
          },
          {
            "returnType": {
              "name": "String",
              "refId": "String"
            },
            "kind": "method",
            "comment": "\nWe keep our behavior specifications in a Map, which is keyed\nby the [CallMatcher]. To make the keys unique and to get a\ndescriptive value for the [CallMatcher] we have this override\nof [toString()].\n",
            "name": "toString",
            "id": "toString0()"
          },
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "comment": "\nGiven a [method] name and list of [arguments], return true\nif it matches this [CallMatcher.\n",
            "name": "matches",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "method",
                "id": "method"
              },
              {
                "ref": {
                  "name": "List",
                  "refId": "List"
                },
                "kind": "param",
                "name": "arguments",
                "id": "arguments"
              }
            ],
            "id": "matches2()"
          },
          {
            "ref": {
              "name": "Matcher",
              "refId": "Matcher"
            },
            "kind": "property",
            "name": "nameFilter",
            "id": "nameFilter"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "Matcher",
                  "refId": "Matcher"
                }
              ]
            },
            "kind": "property",
            "name": "argMatchers",
            "id": "argMatchers"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "comment": "\nConstructor for [CallMatcher]. [name] can be null to\nmatch anything, or a literal [String], a predicate [Function],\nor a [Matcher]. The various arguments can be scalar values or\n[Matcher]s.\n",
            "name": "CallMatcher",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "name",
                "id": "name"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg0",
                "id": "arg0"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg1",
                "id": "arg1"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg2",
                "id": "arg2"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg3",
                "id": "arg3"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg4",
                "id": "arg4"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg5",
                "id": "arg5"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg6",
                "id": "arg6"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg7",
                "id": "arg7"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg8",
                "id": "arg8"
              },
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "isOptional": true,
                "kind": "param",
                "name": "arg9",
                "id": "arg9"
              }
            ],
            "id": "CallMatcher11()"
          }
        ],
        "id": "CallMatcher"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nThe behavior of a method call in the mock library is specified\nwith [Responder]s. A [Responder] has a [value] to throw\nor return (depending on the type of [action]),\nand can either be one-shot, multi-shot, or infinitely repeating,\ndepending on the value of [count (1, greater than 1, or 0 respectively).\n",
        "name": "Responder",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "Responder",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "isOptional": true,
                "kind": "param",
                "name": "count",
                "id": "count"
              },
              {
                "ref": {
                  "name": "Action",
                  "refId": "Action"
                },
                "isOptional": true,
                "kind": "param",
                "name": "action",
                "id": "action"
              }
            ],
            "id": "Responder3()"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "property",
            "name": "value",
            "id": "value"
          },
          {
            "ref": {
              "name": "Action",
              "refId": "Action"
            },
            "kind": "property",
            "name": "action",
            "id": "action"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "property",
            "name": "count",
            "id": "count"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "Responder",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "isOptional": true,
                "kind": "param",
                "name": "count",
                "id": "count"
              },
              {
                "ref": {
                  "name": "Action",
                  "refId": "Action"
                },
                "isOptional": true,
                "kind": "param",
                "name": "action",
                "id": "action"
              }
            ],
            "id": "Responder3()"
          }
        ],
        "id": "Responder"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "The ways in which a call to a mock method can be handled. ",
        "name": "Action",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "Action._",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "name",
                "id": "name"
              }
            ],
            "id": "Action._1()"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isStatic": true,
            "kind": "property",
            "name": "IGNORE",
            "id": "IGNORE"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isStatic": true,
            "kind": "property",
            "name": "RETURN",
            "id": "RETURN"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isStatic": true,
            "kind": "property",
            "name": "THROW",
            "id": "THROW"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isStatic": true,
            "kind": "property",
            "name": "PROXY",
            "id": "PROXY"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "name",
            "id": "name"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "Action._",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "name",
                "id": "name"
              }
            ],
            "id": "Action._1()"
          }
        ],
        "id": "Action"
      }
    ],
    "id": "file:///Users/mhennessy/dart/sudoku/packages/unittest/mock.dart"
  },
  {
    "kind": "library",
    "name": "sudoku",
    "children": [
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "name": "printDebugInfo",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "text",
            "id": "text"
          }
        ],
        "id": "printDebugInfo1()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nThis class contains the unit tests for the Sudoku solver.\n\nTest board\n----------\n003020600\n900305001\n001806400\n008102900\n700000008\n006708200\n002609500\n800203009\n005010300\n",
        "name": "runTests",
        "id": "runTests0()"
      },
      {
        "returnType": {
          "name": "int",
          "refId": "int"
        },
        "kind": "method",
        "comment": "\nConverts two-dimensional [row] and [column] coordinates and converts \nthem to a one-dimensional list index. \n",
        "name": "indexAtGridCoordinates",
        "children": [
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "param",
            "name": "row",
            "id": "row"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "param",
            "name": "column",
            "id": "column"
          }
        ],
        "id": "indexAtGridCoordinates2()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "name": "main",
        "id": "main0()"
      },
      {
        "ref": {
          "name": "String",
          "refId": "String"
        },
        "kind": "property",
        "name": "PUZZLES_HARDEST_11",
        "id": "PUZZLES_HARDEST_11"
      },
      {
        "ref": {
          "name": "String",
          "refId": "String"
        },
        "kind": "property",
        "name": "PUZZLES_HARD_95",
        "id": "PUZZLES_HARD_95"
      },
      {
        "ref": {
          "name": "String",
          "refId": "String"
        },
        "kind": "property",
        "name": "PUZZLES_EASY_50",
        "id": "PUZZLES_EASY_50"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nUtilites for working with collections. \n",
        "name": "CollectionUtils",
        "children": [
          {
            "isStatic": true,
            "returnType": {
              "name": "List",
              "refId": "List"
            },
            "kind": "method",
            "comment": "\nReturns the elements in [b] that are not in [a]\n",
            "name": "subtractListAFromListB",
            "children": [
              {
                "ref": {
                  "name": "List",
                  "refId": "List"
                },
                "kind": "param",
                "name": "a",
                "id": "a"
              },
              {
                "ref": {
                  "name": "List",
                  "refId": "List"
                },
                "kind": "param",
                "name": "b",
                "id": "b"
              }
            ],
            "id": "subtractListAFromListB2()"
          },
          {
            "isStatic": true,
            "returnType": {
              "name": "List",
              "refId": "List"
            },
            "kind": "method",
            "comment": "\nReturns a new [List] with the elements in the given [List] in reverse order.\n",
            "name": "reverse",
            "children": [
              {
                "ref": {
                  "name": "List",
                  "refId": "List"
                },
                "kind": "param",
                "name": "list",
                "id": "list"
              }
            ],
            "id": "reverse1()"
          },
          {
            "isStatic": true,
            "returnType": {
              "name": "int",
              "refId": "int"
            },
            "kind": "method",
            "comment": "\nComparator function for sorting numeric collections in ascending order.\n",
            "name": "compareAscending",
            "children": [
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "a",
                "id": "a"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "b",
                "id": "b"
              }
            ],
            "id": "compareAscending2()"
          },
          {
            "isStatic": true,
            "returnType": {
              "name": "int",
              "refId": "int"
            },
            "kind": "method",
            "comment": "\nComparator function for sorting numeric collections in decending order.\n",
            "name": "compareDecending",
            "children": [
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "a",
                "id": "a"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "b",
                "id": "b"
              }
            ],
            "id": "compareDecending2()"
          }
        ],
        "id": "CollectionUtils"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nRepresents a single cell in the 81 cell [Board].\n",
        "name": "Cell",
        "children": [
          {
            "returnType": {
              "name": "int",
              "refId": "int"
            },
            "kind": "method",
            "name": "value",
            "id": "value0()"
          },
          {
            "isSetter": true,
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "value=",
            "children": [
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "value=1()"
          },
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "comment": "\nTrue if the cell's current value is a number between 1 and 9 inclusive.\n",
            "name": "hasValidValue",
            "id": "hasValidValue0()"
          },
          {
            "returnType": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "int",
                  "refId": "int"
                }
              ]
            },
            "kind": "method",
            "comment": "\nCell values that are not already taken by the cell's box, row, or column [Unit].\n",
            "name": "availableValues",
            "id": "availableValues0()"
          },
          {
            "returnType": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "int",
                  "refId": "int"
                }
              ]
            },
            "kind": "method",
            "comment": "\nCell values that are already taken by the cell's box, row, or column.\n",
            "name": "unavailableValues",
            "id": "unavailableValues0()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "\nConstructor. A cell is not well-formed\nuntil the [_calculatePeers] method is called.\n",
            "name": "Cell._internal",
            "children": [
              {
                "ref": {
                  "name": "Board",
                  "refId": "Board"
                },
                "kind": "param",
                "name": "board",
                "id": "board"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "row",
                "id": "row"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "column",
                "id": "column"
              }
            ],
            "id": "Cell._internal3()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nThis method must be called after the box, row, and column units \nhave been set, but before other properties are used.\n",
            "name": "_calculatePeers",
            "id": "_calculatePeers0()"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "property",
            "name": "value",
            "id": "value"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "property",
            "comment": "\nTrue if the cell's current value is a number between 1 and 9 inclusive.\n",
            "name": "hasValidValue",
            "id": "hasValidValue"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "int",
                  "refId": "int"
                }
              ]
            },
            "kind": "property",
            "comment": "\nCell values that are not already taken by the cell's box, row, or column [Unit].\n",
            "name": "availableValues",
            "id": "availableValues"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "int",
                  "refId": "int"
                }
              ]
            },
            "kind": "property",
            "comment": "\nCell values that are already taken by the cell's box, row, or column.\n",
            "name": "unavailableValues",
            "id": "unavailableValues"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "int",
                  "refId": "int"
                }
              ]
            },
            "isStatic": true,
            "kind": "property",
            "name": "VALID_VALUES",
            "id": "VALID_VALUES"
          },
          {
            "ref": {
              "name": "Board",
              "refId": "Board"
            },
            "kind": "property",
            "name": "board",
            "id": "board"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "property",
            "name": "row",
            "id": "row"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "property",
            "name": "column",
            "id": "column"
          },
          {
            "ref": {
              "name": "Unit",
              "refId": "Unit"
            },
            "kind": "property",
            "name": "boxUnit",
            "id": "boxUnit"
          },
          {
            "ref": {
              "name": "Unit",
              "refId": "Unit"
            },
            "kind": "property",
            "name": "rowUnit",
            "id": "rowUnit"
          },
          {
            "ref": {
              "name": "Unit",
              "refId": "Unit"
            },
            "kind": "property",
            "name": "columnUnit",
            "id": "columnUnit"
          },
          {
            "ref": {
              "name": "Set",
              "refId": "Set",
              "arguments": [
                {
                  "name": "Cell",
                  "refId": "Cell"
                }
              ]
            },
            "kind": "property",
            "name": "peers",
            "id": "peers"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "comment": "\nConstructor. A cell is not well-formed\nuntil the [_calculatePeers] method is called.\n",
            "name": "Cell._internal",
            "children": [
              {
                "ref": {
                  "name": "Board",
                  "refId": "Board"
                },
                "kind": "param",
                "name": "board",
                "id": "board"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "row",
                "id": "row"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "column",
                "id": "column"
              }
            ],
            "id": "Cell._internal3()"
          }
        ],
        "id": "Cell"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nA grouping of cells such as a row, column or block.\n",
        "name": "Unit",
        "children": [
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nAdds the given [Cell] to the unit.\n",
            "name": "add",
            "children": [
              {
                "ref": {
                  "name": "Cell",
                  "refId": "Cell"
                },
                "kind": "param",
                "name": "cell",
                "id": "cell"
              }
            ],
            "id": "add1()"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "Cell",
                  "refId": "Cell"
                }
              ]
            },
            "kind": "property",
            "name": "cells",
            "id": "cells"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "cssClass",
            "id": "cssClass"
          }
        ],
        "id": "Unit"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nThis class represents a 9x9 [Cell] Sudoku board.\n",
        "name": "Board",
        "children": [
          {
            "returnType": {
              "name": "Cell",
              "refId": "Cell"
            },
            "kind": "method",
            "comment": "\nReturns a [Cell] at the given [row] and [column].\n",
            "name": "getCell",
            "children": [
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "row",
                "id": "row"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "column",
                "id": "column"
              }
            ],
            "id": "getCell2()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "Board",
            "children": [
              {
                "ref": {
                  "name": "List",
                  "refId": "List",
                  "arguments": [
                    {
                      "name": "int",
                      "refId": "int"
                    }
                  ]
                },
                "kind": "param",
                "name": "cellValues",
                "id": "cellValues"
              }
            ],
            "id": "Board1()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "\nConstructs the [Board], [Cell]s and [Unit]s.\n",
            "name": "Board._internal",
            "id": "Board._internal0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nExecutes the given [CellFunction] for the given area of the board.\n",
            "name": "_traverseCells",
            "children": [
              {
                "ref": {
                  "name": "CellFunction",
                  "refId": "CellFunction"
                },
                "kind": "param",
                "name": "cellFunc",
                "id": "cellFunc"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "isOptional": true,
                "kind": "param",
                "name": "row",
                "id": "row"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "isOptional": true,
                "kind": "param",
                "name": "column",
                "id": "column"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "isOptional": true,
                "kind": "param",
                "name": "rowSpan",
                "id": "rowSpan"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "isOptional": true,
                "kind": "param",
                "name": "columnSpan",
                "id": "columnSpan"
              }
            ],
            "id": "_traverseCells5()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nTells the board to render itself. An optional [containerSelector] can \nbe specified to select the container DOM element for the board.\n",
            "name": "render",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "containerSelector",
                "id": "containerSelector"
              }
            ],
            "id": "render1()"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "isStatic": true,
            "kind": "property",
            "name": "GRID_SIZE",
            "id": "GRID_SIZE"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "isStatic": true,
            "kind": "property",
            "name": "BOX_SIZE",
            "id": "BOX_SIZE"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "Cell",
                  "refId": "Cell"
                }
              ]
            },
            "kind": "property",
            "name": "cells",
            "id": "cells"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "int",
                  "refId": "int"
                }
              ]
            },
            "kind": "property",
            "name": "cellValues",
            "id": "cellValues"
          },
          {
            "ref": {
              "name": "Board",
              "refId": "Board"
            },
            "isStatic": true,
            "kind": "property",
            "name": "_board",
            "id": "_board"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "Board",
            "children": [
              {
                "ref": {
                  "name": "List",
                  "refId": "List",
                  "arguments": [
                    {
                      "name": "int",
                      "refId": "int"
                    }
                  ]
                },
                "kind": "param",
                "name": "cellValues",
                "id": "cellValues"
              }
            ],
            "id": "Board1()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "comment": "\nConstructs the [Board], [Cell]s and [Unit]s.\n",
            "name": "Board._internal",
            "id": "Board._internal0()"
          }
        ],
        "id": "Board"
      },
      {
        "kind": "typedef",
        "comment": "\nA function that performs operations on specific [Cell]s.\n",
        "name": "CellFunction",
        "id": "CellFunction"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nA parser that parses Sudoku data in string format.\n",
        "name": "Parser",
        "children": [
          {
            "isStatic": true,
            "returnType": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "String",
                  "refId": "String"
                }
              ]
            },
            "kind": "method",
            "comment": "\nParses a string of Sudoku puzzles separated by a [separator] string.\nThe [separator], if not provided, defaults to '\\n'.\n",
            "name": "_splitBoards",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "sudokuData",
                "id": "sudokuData"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "separator",
                "id": "separator"
              }
            ],
            "id": "_splitBoards2()"
          },
          {
            "isStatic": true,
            "returnType": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "int",
                  "refId": "int"
                }
              ]
            },
            "kind": "method",
            "comment": "\nParses a single Sudoku puzzle stored as a string into a list of integer cell values.\n",
            "name": "_parseCellValues",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "puzzle",
                "id": "puzzle"
              }
            ],
            "id": "_parseCellValues1()"
          },
          {
            "isStatic": true,
            "returnType": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "List",
                  "refId": "List",
                  "arguments": [
                    {
                      "name": "int",
                      "refId": "int"
                    }
                  ]
                }
              ]
            },
            "kind": "method",
            "comment": "\nParses [sudokuData], a string that contains multiple Sudoku puzzles, \ninto a list of puzzles. Puzzles are represented as a list of integer cell values.\n",
            "name": "parseSudokuData",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "sudokuData",
                "id": "sudokuData"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "separator",
                "id": "separator"
              }
            ],
            "id": "parseSudokuData2()"
          }
        ],
        "id": "Parser"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "name": "Sudoku",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "Sudoku",
            "id": "Sudoku0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "name": "initializeUI",
            "id": "initializeUI0()"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "List",
                  "refId": "List",
                  "arguments": [
                    {
                      "name": "int",
                      "refId": "int"
                    }
                  ]
                }
              ]
            },
            "kind": "property",
            "name": "previousStates",
            "id": "previousStates"
          },
          {
            "ref": {
              "name": "List",
              "refId": "List",
              "arguments": [
                {
                  "name": "int",
                  "refId": "int"
                }
              ]
            },
            "kind": "property",
            "name": "currentState",
            "id": "currentState"
          },
          {
            "ref": {
              "name": "Board",
              "refId": "Board"
            },
            "kind": "property",
            "name": "board",
            "id": "board"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "Sudoku",
            "id": "Sudoku0()"
          }
        ],
        "id": "Sudoku"
      }
    ],
    "id": "file:///Users/mhennessy/dart/sudoku/sudoku.dart"
  },
  {
    "kind": "library",
    "comment": "\nA library for writing dart unit tests.\n\nTo import this library, use the pub package manager.\nCreate a pubspec.yaml file in your project and add\na dependency on unittest with the following lines:\n    dependencies:\n      unittest:\n        sdk: unittest\n\nThen run 'pub install' from your project directory or using\nthe DartEditor.\n\nPlease see [Pub Getting Started](http://pub.dartlang.org/doc)\nfor more details about the pub package manager.\n\n##Concepts##\n\n * Tests: Tests are specified via the top-level function [test], they can be\n   organized together using [group].\n * Checks: Test expectations can be specified via [expect]\n * Matchers: [expect] assertions are written declaratively using [Matcher]s\n * Configuration: The framework can be adapted by calling [configure] with a\n   [Configuration].  Common configurations can be found in this package\n   under: 'dom\\_config.dart' (deprecated), 'html\\_config.dart' (for running\n   tests compiled to Javascript in a browser), and 'vm\\_config.dart' (for\n   running native Dart tests on the VM).\n\n##Examples##\n\nA trivial test:\n\n    import 'package:unittest/unittest.dart';\n    main() {\n      test('this is a test', () {\n        int x = 2 + 3;\n        expect(x, equals(5));\n      });\n    }\n\nMultiple tests:\n\n    import 'package:unittest/unittest.dart';\n    main() {\n      test('this is a test', () {\n        int x = 2 + 3;\n        expect(x, equals(5));\n      });\n      test('this is another test', () {\n        int x = 2 + 3;\n        expect(x, equals(5));\n      });\n    }\n\nMultiple tests, grouped by category:\n\n    import 'package:unittest/unittest.dart';\n    main() {\n      group('group A', () {\n        test('test A.1', () {\n          int x = 2 + 3;\n          expect(x, equals(5));\n        });\n        test('test A.2', () {\n          int x = 2 + 3;\n          expect(x, equals(5));\n        });\n      });\n      group('group B', () {\n        test('this B.1', () {\n          int x = 2 + 3;\n          expect(x, equals(5));\n        });\n      });\n    }\n\nAsynchronous tests: if callbacks expect between 0 and 2 positional arguments,\ndepending on the suffix of expectAsyncX(). expectAsyncX() will wrap a\nfunction into a new callback and will not consider the test complete until\nthat callback is run. A count argument can be provided to specify the number\nof times the callback should be called (the default is 1).\n\n    import 'package:unittest/unittest.dart';\n    import 'dart:isolate';\n    main() {\n      test('callback is executed once', () {\n        // wrap the callback of an asynchronous call with [expectAsync0] if\n        // the callback takes 0 arguments...\n        var timer = new Timer(0, (_) => expectAsync0(() {\n          int x = 2 + 3;\n          expect(x, equals(5));\n        }));\n      });\n\n      test('callback is executed twice', () {\n        var callback = (_) => expectAsync0(() {\n          int x = 2 + 3;\n          expect(x, equals(5));\n        }, count: 2); // <-- we can indicate multiplicity to [expectAsync0]\n        new Timer(0, callback);\n        new Timer(0, callback);\n      });\n    }\n\nexpectAsyncX() will wrap the callback code in a try/catch handler to handle\nexceptions (treated as test failures). There may be times when the number of\ntimes a callback should be called is non-deterministic. In this case a dummy\ncallback can be created with expectAsync0((){}) and this can be called from\nthe real callback when it is finally complete. In this case the body of the\ncallback should be protected within a call to guardAsync(); this will ensure\nthat exceptions are properly handled.\n\nNote: due to some language limitations we have to use different functions\ndepending on the number of positional arguments of the callback. In the\nfuture, we plan to expose a single `expectAsync` function that can be used\nregardless of the number of positional arguments. This requires new langauge\nfeatures or fixes to the current spec (e.g. see\n[Issue 2706](http://dartbug.com/2706)).\n\nMeanwhile, we plan to add this alternative API for callbacks of more than 2\narguments or that take named parameters. (this is not implemented yet,\nbut will be coming here soon).\n\n    import 'package:unittest/unittest.dart';\n    import 'dart:isolate';\n    main() {\n      test('callback is executed', () {\n        // indicate ahead of time that an async callback is expected.\n        var async = startAsync();\n        new Timer(0, (_) {\n          // Guard the body of the callback, so errors are propagated\n          // correctly.\n          guardAsync(() {\n            int x = 2 + 3;\n            expect(x, equals(5));\n          });\n          // indicate that the asynchronous callback was invoked.\n          async.complete();\n        });\n      });\n    }\n\n",
    "name": "unittest",
    "children": [
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "Disable a test by ID. ",
        "name": "disableTest",
        "children": [
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "param",
            "name": "testId",
            "id": "testId"
          }
        ],
        "id": "disableTest1()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "Enable a test by ID. ",
        "name": "enableTest",
        "children": [
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "param",
            "name": "testId",
            "id": "testId"
          }
        ],
        "id": "enableTest1()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "Enable/disable a test by ID. ",
        "name": "_setTestEnabledState",
        "children": [
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "param",
            "name": "testId",
            "id": "testId"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "param",
            "name": "state",
            "id": "state"
          }
        ],
        "id": "_setTestEnabledState2()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "Select a solo test by ID. ",
        "name": "setSoloTest",
        "children": [
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "param",
            "name": "id",
            "id": "id"
          }
        ],
        "id": "setSoloTest1()"
      },
      {
        "returnType": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "method",
        "comment": "\nLazily initializes the test library if not already initialized.\n",
        "name": "ensureInitialized",
        "id": "ensureInitialized0()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "name": "fail",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "message",
            "id": "message"
          }
        ],
        "id": "fail1()"
      },
      {
        "returnType": {
          "name": "String",
          "refId": "String"
        },
        "kind": "method",
        "name": "_fullSpec",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "spec",
            "id": "spec"
          }
        ],
        "id": "_fullSpec1()"
      },
      {
        "returnType": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "method",
        "comment": "Publish results on the page and notify controller. ",
        "name": "_completeTests",
        "id": "_completeTests0()"
      },
      {
        "returnType": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "method",
        "comment": "\nRuns a batch of tests, yielding whenever an asynchronous test starts\nrunning. Tests will resume executing when such asynchronous test calls\n[done] or if it fails with an exception.\n",
        "name": "_nextBatch",
        "id": "_nextBatch0()"
      },
      {
        "returnType": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "method",
        "comment": "\nRegisters that an exception was caught for the current test.\n",
        "name": "_registerException",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "testNum",
            "id": "testNum"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "e",
            "id": "e"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "trace",
            "id": "trace"
          }
        ],
        "id": "_registerException3()"
      },
      {
        "returnType": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "method",
        "comment": "\nRegisters that an exception was caught for the current test.\n",
        "name": "registerException",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "e",
            "id": "e"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "trace",
            "id": "trace"
          }
        ],
        "id": "registerException2()"
      },
      {
        "returnType": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "method",
        "comment": "\nRun [tryBody] guarded in a try-catch block. If an exception is thrown, update\nthe [_currentTest] status accordingly.\n",
        "name": "guardAsync",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "tryBody",
            "id": "tryBody"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "finallyBody",
            "id": "finallyBody"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "isOptional": true,
            "kind": "param",
            "name": "testNum",
            "id": "testNum"
          }
        ],
        "id": "guardAsync3()"
      },
      {
        "returnType": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "method",
        "comment": "Runs all queued tests, one at a time. ",
        "name": "runTests",
        "id": "runTests0()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nFilter the tests. [testFilter] can be a [RegExp], a [String] or a\npredicate function. This is different to enabling/disabling tests\nin that it removes the tests completely.\n",
        "name": "filterTests",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "testFilter",
            "id": "testFilter"
          }
        ],
        "id": "filterTests1()"
      },
      {
        "returnType": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "method",
        "name": "rerunTests",
        "id": "rerunTests0()"
      },
      {
        "returnType": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "method",
        "comment": "Runs [callback] at the end of the event loop. ",
        "name": "_defer",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          }
        ],
        "id": "_defer1()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nUtility function that can be used to notify the test framework that an\n error was caught outside of this library.\n",
        "name": "_reportTestError",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "msg",
            "id": "msg"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "trace",
            "id": "trace"
          }
        ],
        "id": "_reportTestError2()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nTemporary hack: expose old API.\nTODO(gram) remove this when WebKit tests are working with new framework\n",
        "name": "callbackDone",
        "id": "callbackDone0()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "Advance to the next test case. ",
        "name": "_nextTestCase",
        "id": "_nextTestCase0()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nCalled when one of the callback functions is done with all expected\ncalls.\n",
        "name": "_handleCallbackFunctionComplete",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "testNum",
            "id": "testNum"
          }
        ],
        "id": "_handleCallbackFunctionComplete1()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nRegister a [tearDown] function for a test [group]. This function will\nbe called after each test in the group is run. Note that if groups\nare nested only the most locally scoped [tearDown] function will be run.\n[setUp] and [tearDown] should be called within the [group] before any\ncalls to [test].\n",
        "name": "tearDown",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "teardownTest",
            "id": "teardownTest"
          }
        ],
        "id": "tearDown1()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nRegister a [setUp] function for a test [group]. This function will\nbe called before each test in the group is run. Note that if groups\nare nested only the most locally scoped [setUp] function will be run.\n[setUp] and [tearDown] should be called within the [group] before any\ncalls to [test].\n",
        "name": "setUp",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "setupTest",
            "id": "setupTest"
          }
        ],
        "id": "setUp1()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nCreates a new named group of tests. Calls to group() or test() within the\nbody of the function passed to this will inherit this group's description.\n",
        "name": "group",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "description",
            "id": "description"
          },
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "body",
            "id": "body"
          }
        ],
        "id": "group2()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "\nLike [protectAsync0] but [callback] should take 2 positional arguments.\n",
        "name": "protectAsync2",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          }
        ],
        "id": "protectAsync21()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "\nLike [protectAsync0] but [callback] should take 1 positional argument.\n",
        "name": "protectAsync1",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          }
        ],
        "id": "protectAsync11()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "\nWraps the [callback] in a new function and returns that function. The new\nfunction will be able to handle exceptions by directing them to the correct\ntest. This is thus similar to expectAsync0. Use it to wrap any callbacks that\nmight optionally be called but may never be called during the test.\n[callback] should take 0 positional arguments (named arguments are not\nsupported).\n",
        "name": "protectAsync0",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          }
        ],
        "id": "protectAsync01()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "\nWraps the [callback] in a new function and returns that function. The new\nfunction will be able to handle exceptions by directing them to the correct\ntest. This is thus similar to expectAsync0. Use it to wrap any callbacks that\nmight optionally be called but may never be called during the test.\n[callback] should take between 0 and 4 positional arguments (named arguments\nare not supported).\n",
        "name": "_protectAsync",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          }
        ],
        "id": "_protectAsync1()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "\nLike [expectAsyncUntil0] but [callback] should take 2 positional arguments.\n",
        "name": "expectAsyncUntil2",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          },
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "isDone",
            "id": "isDone"
          }
        ],
        "id": "expectAsyncUntil22()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "\nLike [expectAsyncUntil0] but [callback] should take 1 positional argument.\n",
        "name": "expectAsyncUntil1",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          },
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "isDone",
            "id": "isDone"
          }
        ],
        "id": "expectAsyncUntil12()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "\nIndicate that [callback] is expected to be called until [isDone] returns\ntrue. The unittest framework check [isDone] after each callback and only\nwhen it returns true will it continue with the following test. Using\n[expectAsyncUntil0] will also ensure that errors that occur within\n[callback] are tracked and reported. [callback] should take 0 positional\narguments (named arguments are not supported).\n",
        "name": "expectAsyncUntil0",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          },
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "isDone",
            "id": "isDone"
          }
        ],
        "id": "expectAsyncUntil02()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "\nIndicate that [callback] is expected to be called until [isDone] returns\ntrue. The unittest framework checks [isDone] after each callback and only\nwhen it returns true will it continue with the following test. Using\n[expectAsyncUntil] will also ensure that errors that occur within\n[callback] are tracked and reported. [callback] should take between 0 and\n4 positional arguments (named arguments are not supported).\n",
        "name": "_expectAsyncUntil",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          },
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "isDone",
            "id": "isDone"
          }
        ],
        "id": "_expectAsyncUntil2()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "Like [expectAsync0] but [callback] should take 2 positional arguments. ",
        "name": "expectAsync2",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "isOptional": true,
            "kind": "param",
            "name": "count",
            "id": "count"
          }
        ],
        "id": "expectAsync22()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "Like [expectAsync0] but [callback] should take 1 positional argument. ",
        "name": "expectAsync1",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "isOptional": true,
            "kind": "param",
            "name": "count",
            "id": "count"
          }
        ],
        "id": "expectAsync12()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "\nIndicate that [callback] is expected to be called a [count] number of times\n(by default 1). The unittest framework will wait for the callback to run the\nspecified [count] times before it continues with the following test.  Using\n[expectAsync0] will also ensure that errors that occur within [callback] are\ntracked and reported. [callback] should take 0 positional arguments (named\narguments are not supported).\n",
        "name": "expectAsync0",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "isOptional": true,
            "kind": "param",
            "name": "count",
            "id": "count"
          }
        ],
        "id": "expectAsync02()"
      },
      {
        "returnType": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "method",
        "comment": "\nIndicate that [callback] is expected to be called a [count] number of times\n(by default 1). The unittest framework will wait for the callback to run the\nspecified [count] times before it continues with the following test.  Using\n[_expectAsync] will also ensure that errors that occur within [callback] are\ntracked and reported. [callback] should take between 0 and 4 positional\narguments (named arguments are not supported here).\n",
        "name": "_expectAsync",
        "children": [
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "param",
            "name": "callback",
            "id": "callback"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "isOptional": true,
            "kind": "param",
            "name": "count",
            "id": "count"
          }
        ],
        "id": "_expectAsync2()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nCreates a new test case with the given description and body. The\ndescription will include the descriptions of any surrounding group()\ncalls.\n\n\"solo_\" means that this will be the only test that is run. All other tests\nwill be skipped. This is a convenience function to let you quickly isolate\na single test by adding \"solo_\" before it to temporarily disable all other\ntests.\n",
        "name": "solo_test",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "spec",
            "id": "spec"
          },
          {
            "ref": {
              "name": "TestFunction",
              "refId": "TestFunction"
            },
            "kind": "param",
            "name": "body",
            "id": "body"
          }
        ],
        "id": "solo_test2()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\n(Deprecated) Creates a new async test case with the given description\nand body. The description will include the descriptions of any surrounding\ngroup() calls.\n",
        "name": "asyncTest",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "spec",
            "id": "spec"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "param",
            "name": "callbacks",
            "id": "callbacks"
          },
          {
            "ref": {
              "name": "TestFunction",
              "refId": "TestFunction"
            },
            "kind": "param",
            "name": "body",
            "id": "body"
          }
        ],
        "id": "asyncTest3()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\nCreates a new test case with the given description and body. The\ndescription will include the descriptions of any surrounding group()\ncalls.\n",
        "name": "test",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "spec",
            "id": "spec"
          },
          {
            "ref": {
              "name": "TestFunction",
              "refId": "TestFunction"
            },
            "kind": "param",
            "name": "body",
            "id": "body"
          }
        ],
        "id": "test2()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "comment": "\n(Deprecated) Evaluates the [function] and validates that it throws an\nexception. If [callback] is provided, then it will be invoked with the\nthrown exception. The callback may do any validation it wants. In addition,\nif it returns `false`, that also indicates an expectation failure.\n",
        "name": "expectThrow",
        "children": [
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "param",
            "name": "function",
            "id": "function"
          },
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "isOptional": true,
            "kind": "param",
            "name": "callback",
            "id": "callback"
          }
        ],
        "id": "expectThrow2()"
      },
      {
        "returnType": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "method",
        "comment": "Get the list of tests. ",
        "name": "testCases",
        "id": "testCases0()"
      },
      {
        "returnType": {
          "name": "void",
          "refId": "void"
        },
        "kind": "method",
        "name": "logMessage",
        "children": [
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "param",
            "name": "message",
            "id": "message"
          }
        ],
        "id": "logMessage1()"
      },
      {
        "returnType": {
          "name": "Configuration",
          "refId": "Configuration"
        },
        "kind": "method",
        "comment": "\nSet the [Configuration] used by the unittest library. Returns any\nprevious configuration.\nTODO: consider deprecating in favor of a setter now we have a getter.\n",
        "name": "configure",
        "children": [
          {
            "ref": {
              "name": "Configuration",
              "refId": "Configuration"
            },
            "kind": "param",
            "name": "config",
            "id": "config"
          }
        ],
        "id": "configure1()"
      },
      {
        "returnType": {
          "name": "Configuration",
          "refId": "Configuration"
        },
        "kind": "method",
        "name": "config",
        "id": "config0()"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "comment": "Get the list of tests. ",
        "name": "testCases",
        "id": "testCases"
      },
      {
        "ref": {
          "name": "Configuration",
          "refId": "Configuration"
        },
        "kind": "property",
        "name": "config",
        "id": "config"
      },
      {
        "ref": {
          "name": "Map",
          "refId": "Map"
        },
        "kind": "property",
        "name": "testState",
        "id": "testState"
      },
      {
        "ref": {
          "name": "TestCase",
          "refId": "TestCase"
        },
        "kind": "property",
        "name": "_soloTest",
        "id": "_soloTest"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "ERROR",
        "id": "ERROR"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "FAIL",
        "id": "FAIL"
      },
      {
        "ref": {
          "name": "dynamic",
          "refId": "dynamic"
        },
        "kind": "property",
        "name": "PASS",
        "id": "PASS"
      },
      {
        "ref": {
          "name": "String",
          "refId": "String"
        },
        "kind": "property",
        "name": "_uncaughtErrorMessage",
        "id": "_uncaughtErrorMessage"
      },
      {
        "ref": {
          "name": "bool",
          "refId": "bool"
        },
        "kind": "property",
        "name": "_initialized",
        "id": "_initialized"
      },
      {
        "ref": {
          "name": "int",
          "refId": "int"
        },
        "kind": "property",
        "name": "_currentTest",
        "id": "_currentTest"
      },
      {
        "ref": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "property",
        "name": "_testTeardown",
        "id": "_testTeardown"
      },
      {
        "ref": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "property",
        "name": "_testSetup",
        "id": "_testSetup"
      },
      {
        "ref": {
          "name": "Function",
          "refId": "Function"
        },
        "kind": "property",
        "name": "_testRunner",
        "id": "_testRunner"
      },
      {
        "ref": {
          "name": "List",
          "refId": "List",
          "arguments": [
            {
              "name": "TestCase",
              "refId": "TestCase"
            }
          ]
        },
        "kind": "property",
        "name": "_tests",
        "id": "_tests"
      },
      {
        "ref": {
          "name": "String",
          "refId": "String"
        },
        "kind": "property",
        "name": "groupSep",
        "id": "groupSep"
      },
      {
        "ref": {
          "name": "String",
          "refId": "String"
        },
        "kind": "property",
        "name": "_currentGroup",
        "id": "_currentGroup"
      },
      {
        "ref": {
          "name": "Configuration",
          "refId": "Configuration"
        },
        "kind": "property",
        "name": "_config",
        "id": "_config"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "name": "TestCase",
        "children": [
          {
            "returnType": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "method",
            "name": "setUp",
            "id": "setUp0()"
          },
          {
            "isSetter": true,
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "setUp=",
            "children": [
              {
                "ref": {
                  "name": "Function",
                  "refId": "Function"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "setUp=1()"
          },
          {
            "returnType": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "method",
            "name": "tearDown",
            "id": "tearDown0()"
          },
          {
            "isSetter": true,
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "tearDown=",
            "children": [
              {
                "ref": {
                  "name": "Function",
                  "refId": "Function"
                },
                "kind": "param",
                "name": "value",
                "id": "value"
              }
            ],
            "id": "tearDown=1()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "TestCase",
            "children": [
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "id",
                "id": "id"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "description",
                "id": "description"
              },
              {
                "ref": {
                  "name": "TestFunction",
                  "refId": "TestFunction"
                },
                "kind": "param",
                "name": "test",
                "id": "test"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "callbackFunctionsOutstanding",
                "id": "callbackFunctionsOutstanding"
              }
            ],
            "id": "TestCase4()"
          },
          {
            "returnType": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "method",
            "name": "isComplete",
            "id": "isComplete0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "name": "run",
            "id": "run0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "name": "_complete",
            "id": "_complete0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "name": "pass",
            "id": "pass0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "name": "fail",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "messageText",
                "id": "messageText"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "stack",
                "id": "stack"
              }
            ],
            "id": "fail2()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "name": "error",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "messageText",
                "id": "messageText"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "isOptional": true,
                "kind": "param",
                "name": "stack",
                "id": "stack"
              }
            ],
            "id": "error2()"
          },
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "property",
            "name": "setUp",
            "id": "setUp"
          },
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "property",
            "name": "tearDown",
            "id": "tearDown"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "property",
            "name": "isComplete",
            "id": "isComplete"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "property",
            "name": "id",
            "id": "id"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "description",
            "id": "description"
          },
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "property",
            "name": "_setUp",
            "id": "_setUp"
          },
          {
            "ref": {
              "name": "Function",
              "refId": "Function"
            },
            "kind": "property",
            "name": "_tearDown",
            "id": "_tearDown"
          },
          {
            "ref": {
              "name": "TestFunction",
              "refId": "TestFunction"
            },
            "kind": "property",
            "name": "test",
            "id": "test"
          },
          {
            "ref": {
              "name": "int",
              "refId": "int"
            },
            "kind": "property",
            "name": "callbackFunctionsOutstanding",
            "id": "callbackFunctionsOutstanding"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "message",
            "id": "message"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "result",
            "id": "result"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "stackTrace",
            "id": "stackTrace"
          },
          {
            "ref": {
              "name": "String",
              "refId": "String"
            },
            "kind": "property",
            "name": "currentGroup",
            "id": "currentGroup"
          },
          {
            "ref": {
              "name": "DateTime",
              "refId": "DateTime"
            },
            "kind": "property",
            "name": "startTime",
            "id": "startTime"
          },
          {
            "ref": {
              "name": "Duration",
              "refId": "Duration"
            },
            "kind": "property",
            "name": "runningTime",
            "id": "runningTime"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "property",
            "name": "enabled",
            "id": "enabled"
          },
          {
            "ref": {
              "name": "bool",
              "refId": "bool"
            },
            "kind": "property",
            "name": "_doneTeardown",
            "id": "_doneTeardown"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "constructor",
            "name": "TestCase",
            "children": [
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "id",
                "id": "id"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "description",
                "id": "description"
              },
              {
                "ref": {
                  "name": "TestFunction",
                  "refId": "TestFunction"
                },
                "kind": "param",
                "name": "test",
                "id": "test"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "callbackFunctionsOutstanding",
                "id": "callbackFunctionsOutstanding"
              }
            ],
            "id": "TestCase4()"
          }
        ],
        "id": "TestCase"
      },
      {
        "superclass": {
          "name": "Object",
          "refId": "Object"
        },
        "kind": "class",
        "comment": "\nHooks to configure the unittest library for different platforms. This class\nimplements the API in a platform-independent way. Tests that want to take\nadvantage of the platform can create a subclass and override methods from\nthis class.\n",
        "name": "Configuration",
        "children": [
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "\nSubclasses can override this with something useful for diagnostics.\nParticularly useful in cases where we have parent/child configurations\nsuch as layout tests.\n",
            "name": "name",
            "id": "name0()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "\nIf true, then tests are started automatically (otherwise [runTests]\nmust be called explicitly after the tests are set up.\n",
            "name": "autoStart",
            "id": "autoStart0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nCalled as soon as the unittest framework becomes initialized. This is done\neven before tests are added to the test framework. It might be used to\ndetermine/debug errors that occur before the test harness starts executing.\nIt is also used to tell the vm or browser that tests are going to be run\nasynchronously and that the process should wait until they are done.\n",
            "name": "onInit",
            "id": "onInit0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "Called as soon as the unittest framework starts running. ",
            "name": "onStart",
            "id": "onStart0()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nCalled when each test starts. Useful to show intermediate progress on\na test suite.\n",
            "name": "onTestStart",
            "children": [
              {
                "ref": {
                  "name": "TestCase",
                  "refId": "TestCase"
                },
                "kind": "param",
                "name": "testCase",
                "id": "testCase"
              }
            ],
            "id": "onTestStart1()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nCalled when each test is completed. Useful to show intermediate progress on\na test suite.\n",
            "name": "onTestResult",
            "children": [
              {
                "ref": {
                  "name": "TestCase",
                  "refId": "TestCase"
                },
                "kind": "param",
                "name": "testCase",
                "id": "testCase"
              }
            ],
            "id": "onTestResult1()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nCan be called by tests to log status. Tests should use this\ninstead of print. Subclasses should not override this; they\nshould instead override logMessage which is passed the test case.\n",
            "name": "logMessage",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "message",
                "id": "message"
              }
            ],
            "id": "logMessage1()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nHandles the logging of messages by a test case. The default in\nthis base configuration is to call print();\n",
            "name": "logTestCaseMessage",
            "children": [
              {
                "ref": {
                  "name": "TestCase",
                  "refId": "TestCase"
                },
                "kind": "param",
                "name": "testCase",
                "id": "testCase"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "message",
                "id": "message"
              }
            ],
            "id": "logTestCaseMessage2()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nCalled with the result of all test cases. The default implementation prints\nthe result summary using the built-in [print] command. Browser tests\ncommonly override this to reformat the output.\n\nWhen [uncaughtError] is not null, it contains an error that occured outside\nof tests (e.g. setting up the test).\n",
            "name": "onSummary",
            "children": [
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "passed",
                "id": "passed"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "failed",
                "id": "failed"
              },
              {
                "ref": {
                  "name": "int",
                  "refId": "int"
                },
                "kind": "param",
                "name": "errors",
                "id": "errors"
              },
              {
                "ref": {
                  "name": "List",
                  "refId": "List",
                  "arguments": [
                    {
                      "name": "TestCase",
                      "refId": "TestCase"
                    }
                  ]
                },
                "kind": "param",
                "name": "results",
                "id": "results"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "uncaughtError",
                "id": "uncaughtError"
              }
            ],
            "id": "onSummary5()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nCalled when the unittest framework is done running. [success] indicates\nwhether all tests passed successfully.\n",
            "name": "onDone",
            "children": [
              {
                "ref": {
                  "name": "bool",
                  "refId": "bool"
                },
                "kind": "param",
                "name": "success",
                "id": "success"
              }
            ],
            "id": "onDone1()"
          },
          {
            "returnType": {
              "name": "String",
              "refId": "String"
            },
            "kind": "method",
            "name": "_indent",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "str",
                "id": "str"
              }
            ],
            "id": "_indent1()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "comment": "Handle errors that happen outside the tests. ",
            "name": "handleExternalError",
            "children": [
              {
                "ref": {
                  "name": "dynamic",
                  "refId": "dynamic"
                },
                "kind": "param",
                "name": "e",
                "id": "e"
              },
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "message",
                "id": "message"
              }
            ],
            "id": "handleExternalError2()"
          },
          {
            "returnType": {
              "name": "void",
              "refId": "void"
            },
            "kind": "method",
            "comment": "\nSend messages to the test controller code (see 'test_controller.js'). This\nis only needed to support browser tests with dart2js. Note: we could wrap\ntests and send the appropriate messages to the controller through the\nwrapper, but using wrappers has a noticeable overhead in the testing bots,\nso we use this approach instead.\n\nConfigurations that will not run in DRT (such as vm_config and\ncompact_vm_config), can safely override this method to avoid printing extra\nmesages in the console.\n",
            "name": "notifyController",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "message",
                "id": "message"
              }
            ],
            "id": "notifyController1()"
          },
          {
            "returnType": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "method",
            "name": "_postMessage",
            "children": [
              {
                "ref": {
                  "name": "String",
                  "refId": "String"
                },
                "kind": "param",
                "name": "message",
                "id": "message"
              }
            ],
            "id": "_postMessage1()"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "property",
            "comment": "\nSubclasses can override this with something useful for diagnostics.\nParticularly useful in cases where we have parent/child configurations\nsuch as layout tests.\n",
            "name": "name",
            "id": "name"
          },
          {
            "ref": {
              "name": "dynamic",
              "refId": "dynamic"
            },
            "kind": "property",
            "comment": "\nIf true, then tests are started automatically (otherwise [runTests]\nmust be called explicitly after the tests are set up.\n",
            "name": "autoStart",
            "id": "autoStart"
          },
          {
            "ref": {
              "name": "ReceivePort",
              "refId": "ReceivePort"
            },
            "kind": "property",
            "name": "_receivePort",
            "id": "_receivePort"
          },
          {
            "ref": {
              "name": "TestCase",
              "refId": "TestCase"
            },
            "kind": "property",
            "name": "currentTestCase",
            "id": "currentTestCase"
          }
        ],
        "id": "Configuration"
      },
      {
        "kind": "typedef",
        "comment": "Signature for a test function. ",
        "name": "TestFunction",
        "id": "TestFunction"
      }
    ],
    "id": "file:///Users/mhennessy/dart/sudoku/packages/unittest/unittest.dart"
  }
]