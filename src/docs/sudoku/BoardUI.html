        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>BoardUI class / sudoku Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="sudoku" data-type="BoardUI">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../sudoku.html">sudoku</a> &rsaquo; <a href="../sudoku/BoardUI.html">BoardUI</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../metadata.html">metadata</a></h2><h2><div class="icon-library"></div><a href="../sudoku.html">sudoku</a></h2><ul class="icon">
<li><a href="../sudoku/Board.html"><div class="icon-class"></div>Board</a></li>
<li><div class="icon-class"></div><strong>BoardUI</strong></li>
<li><a href="../sudoku/Cell.html"><div class="icon-class"></div>Cell</a></li>
<li><a href="../sudoku/CollectionUtils.html"><div class="icon-class"></div>CollectionUtils</a></li>
<li><a href="../sudoku/CSS.html"><div class="icon-class"></div>CSS</a></li>
<li><a href="../sudoku/DomUtils.html"><div class="icon-class"></div>DomUtils</a></li>
<li><a href="../sudoku/GameState.html"><div class="icon-class"></div>GameState</a></li>
<li><a href="../sudoku/IO.html"><div class="icon-class"></div>IO</a></li>
<li><a href="../sudoku/Keyboard.html"><div class="icon-class"></div>Keyboard</a></li>
<li><a href="../sudoku/Parser.html"><div class="icon-class"></div>Parser</a></li>
<li><a href="../sudoku/StringUtils.html"><div class="icon-class"></div>StringUtils</a></li>
<li><a href="../sudoku/SudokuGame.html"><div class="icon-class"></div>SudokuGame</a></li>
<li><a href="../sudoku/SudokuSolver.html"><div class="icon-class"></div>SudokuSolver</a></li>
<li><a href="../sudoku/Unit.html"><div class="icon-class"></div>Unit</a></li>
</ul>
</div>
<div class="content">
        <h2><strong>BoardUI</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class BoardUI {
 Board _board;

 String boardTitle;

 HeadingElement _titleElement;
 HeadingElement get titleElement =&gt; _titleElement;

 Map&lt;Cell, Element&gt; _cellElementMap;
 List&lt;Cell&gt; get cells =&gt; _cellElementMap.keys.toList();
 List&lt;Element&gt; get cellElements =&gt; _cellElementMap.values.toList();

 Keyboard _keyboard;

 bool _isRendered = false;
 bool get isRendered =&gt; _isRendered;

 List&lt;String&gt; _temporaryCellStyles = [CSS.CONTRADICTION_SOURCE_CELL, CSS.CONTRADICTION_CELL];

 BoardUI(Board board) {
   _board = board;

   _cellElementMap = new Map&lt;Cell, Element&gt;();
   _keyboard = new Keyboard();
 }

 void update([String puzzleTitle]) {
   if(isRendered) {
     refresh(boardTitle);
   } else {
     render(boardTitle);
   }
 }

 void renderGameState(GameState gameState, [String puzzleTitle]) {
   if(_board != gameState.board)
     throw "The board for which the UI was created must match the board of the game state";

   _board.cellValues = gameState.cellValues;

   render(puzzleTitle);

   for(Cell cell in cells) {
     if(gameState.changedCells.contains(cell)) {
       var cellElement = _cellElementMap[cell];
       cellElement.classes.add(CSS.RECENTLY_MODIFIED_CELL);
     }
   }
 }

 void render([String puzzleTitle]) {
   var elements = new List&lt;Element&gt;();

   _titleElement = new HeadingElement.h3();
   elements.add(titleElement);

   var grid = constructGrid();
   elements.add(grid);

   _addGridElementsToDom(elements);
   _isRendered = true;
   refresh(puzzleTitle);
 }

 void refresh([String puzzleTitle]) {
   _setTitle(puzzleTitle);
   for(var cell in cells) {
     _renderCellValue(cell);
     _setCellStyle(cell);
     _clearTemporaryCellStyle(cell);
   }
 }

 void _setTitle(String title) {
   titleElement.text = title != null ? title : "";
 }

 void _setCellStyle(Cell cell) {
   var cellElement = _cellElementMap[cell];
   if(cell.isValueFixed) {
     cellElement.classes.add(CSS.FIXED_VALUE_CELL);
   } else {
     cellElement.classes.remove(CSS.FIXED_VALUE_CELL);
   }
 }

 void _addGridElementsToDom(List&lt;Element&gt; gridElements) {
   var div = new DivElement();
   for(var element in gridElements) {
     div.children.add(element);
   }
   div.children.add(new BRElement());

   var puzzleContainer = query(CSS.PUZZLE_CONTAINER);
   puzzleContainer.children
   ..add(div);
 }

 Element constructGrid() {
   var grid = new TableElement();
   grid.classes.add(CSS.GRID);
   for(int r = 0; r &lt; Board.GRID_SIZE; r++) {
     var rowElement = grid.insertRow(r);
     for(int c = 0; c &lt; Board.GRID_SIZE; c++) {
       Cell cell = _board.getCell(r, c);
       Element cellElement = rowElement.insertCell(c);
       _cellElementMap[cell] = cellElement;
       cellElement.classes.add(CSS.CELL);
       cellElement.classes.add(cell.boxUnit.cssClass);
       _initializeUserInput(cell);
       _initializePeerHighlighting(cell);
     }
   }
   return grid;
 }

 void _renderCellValue(Cell cell) {
   _cellElementMap[cell]
   ..text = cell.hasValue ? cell.value.toString() : "";
 }

 void _initializeUserInput(Cell cell) {
   var cellElement = _cellElementMap[cell];
   DomUtils.makeFocusable(cellElement);
   cellElement
   ..onMouseOver.listen((e) {
     _selectCellElement(cellElement);
   })
   ..onMouseOut.listen((e) {
     _unselectCellElement(cellElement);
   })
   ..onKeyDown.listen((e) {
     if(Keyboard.isNumericKey(e) &amp;&amp; !cell.isValueFixed) {
       _updateCellValue(cell, e);
     } else if(Keyboard.isArrowKey(e)) {
       _moveToNextCell(cell, e);
     }
   });
 }

 void _selectCellElement(Element cellElement) {
   cellElement.focus();
   cellElement.classes.add(CSS.SELECTED_CELL);
 }

 void _unselectCellElement(Element cellElement) {
   cellElement.blur();
   cellElement.classes.remove(CSS.SELECTED_CELL);
 }

 void _updateCellValue(Cell cell, KeyboardEvent e) {
   var value = Keyboard.parseKeyAsInt(e);
   updateCellValue(cell, value);
 }

 void updateCellValue(Cell cell, int value) {
   cell.value = value;
   _renderCellValue(cell);
   _updateStyle(cell);
 }

 void _updateStyle(Cell cell) {
   for(var c in cells) {
     _clearTemporaryCellStyle(c);
     var recentlyChanged = (c == cell);
     _setTemporaryCellStyle(c, recentlyChanged);
   }
 }

 void _clearTemporaryCellStyle(Cell cell) {
   var cellElement = _cellElementMap[cell];
   for(var style in _temporaryCellStyles) {
     cellElement.classes.remove(style);
   }
 }

 void _setTemporaryCellStyle(Cell cell, bool recentlyChanged) {
   var cellElement = _cellElementMap[cell];
   if(cell.hasContradiction) {
     var contradictionStyle = recentlyChanged ? CSS.CONTRADICTION_SOURCE_CELL : CSS.CONTRADICTION_CELL;
     cellElement.classes.add(contradictionStyle);
   }
 }

 void _moveToNextCell(Cell cell, KeyboardEvent e) {
   var row = cell.row;
   var column = cell.column;
   if(Keyboard.isEventForKey(e, KeyCode.LEFT)) {
     column -= 1;
   } else if(Keyboard.isEventForKey(e, KeyCode.UP)) {
     row -= 1;
   } else if(Keyboard.isEventForKey(e, KeyCode.RIGHT)) {
     column += 1;
   } else if(Keyboard.isEventForKey(e, KeyCode.DOWN)) {
     row += 1;
   }
   if(Board.gridCoordinatesInBounds(row, column)) {
     var nextCell = _board.getCell(row, column);
     _selectCellElement(_cellElementMap[nextCell]);
   }
   _preventScrollbarFromMoving(e);
 }

 void _preventScrollbarFromMoving(KeyboardEvent event) {
   event.preventDefault();
 }

 void _initializePeerHighlighting(Cell cell) {
   var currentHighlightState = false;

   void highlightPeers(bool highlight) {
     if(highlight != currentHighlightState) {
       var peerElements = cell.peers.map((c) =&gt; _cellElementMap[c]);
       for(Element element in peerElements) {
         element.classes.toggle(CSS.HIGHLIGHTED_PEER_CELL);
       }
       currentHighlightState = !currentHighlightState;
     }
   }

   _cellElementMap[cell]
   ..onFocus.listen((e) {
     if(_keyboard.isHighlightPeersKeyPressed) {
       highlightPeers(true);
     }
   })
   ..onBlur.listen((e) {
     highlightPeers(false);
   })
   ..onKeyDown.listen((e) {
     if(Keyboard.isEventForKey(e, Keyboard.HIGHLIGHT_PEERS_KEY)) {
       highlightPeers(true);
     }
   })
   ..onKeyUp.listen((e) {
     if(_keyboard.isHighlightPeersKeyPressed) {
       highlightPeers(false);
     }
   });
 }

}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="BoardUI">
<button class="show-code">Code</button>
new <strong>BoardUI</strong>(<a href="../sudoku/Board.html">Board</a> board) <a class="anchor-link" href="#BoardUI"
              title="Permalink to BoardUI.BoardUI">#</a></h4>
<div class="doc">
<pre class="source">
BoardUI(Board board) {
 _board = board;

 _cellElementMap = new Map&lt;Cell, Element&gt;();
 _keyboard = new Keyboard();
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="boardTitle">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>boardTitle</strong> <a class="anchor-link"
            href="#boardTitle"
            title="Permalink to BoardUI.boardTitle">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String boardTitle
</pre>
</div>
</div>
<div class="field"><h4 id="cellElements">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_html/Element.html">Element</a>&gt;         <strong>cellElements</strong> <a class="anchor-link"
            href="#cellElements"
            title="Permalink to BoardUI.cellElements">#</a>
        </h4>
        <div class="doc">
<pre class="source">
List&lt;Element&gt; get cellElements =&gt; _cellElementMap.values.toList();
</pre>
</div>
</div>
<div class="field"><h4 id="cells">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../sudoku/Cell.html">Cell</a>&gt;         <strong>cells</strong> <a class="anchor-link"
            href="#cells"
            title="Permalink to BoardUI.cells">#</a>
        </h4>
        <div class="doc">
<pre class="source">
List&lt;Cell&gt; get cells =&gt; _cellElementMap.keys.toList();
</pre>
</div>
</div>
<div class="field"><h4 id="isRendered">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>isRendered</strong> <a class="anchor-link"
            href="#isRendered"
            title="Permalink to BoardUI.isRendered">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool get isRendered =&gt; _isRendered;
</pre>
</div>
</div>
<div class="field"><h4 id="titleElement">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_html/HeadingElement.html">HeadingElement</a>         <strong>titleElement</strong> <a class="anchor-link"
            href="#titleElement"
            title="Permalink to BoardUI.titleElement">#</a>
        </h4>
        <div class="doc">
<pre class="source">
HeadingElement get titleElement =&gt; _titleElement;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="constructGrid">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_html/Element.html">Element</a> <strong>constructGrid</strong>() <a class="anchor-link" href="#constructGrid"
              title="Permalink to BoardUI.constructGrid">#</a></h4>
<div class="doc">
<pre class="source">
Element constructGrid() {
 var grid = new TableElement();
 grid.classes.add(CSS.GRID);
 for(int r = 0; r &lt; Board.GRID_SIZE; r++) {
   var rowElement = grid.insertRow(r);
   for(int c = 0; c &lt; Board.GRID_SIZE; c++) {
     Cell cell = _board.getCell(r, c);
     Element cellElement = rowElement.insertCell(c);
     _cellElementMap[cell] = cellElement;
     cellElement.classes.add(CSS.CELL);
     cellElement.classes.add(cell.boxUnit.cssClass);
     _initializeUserInput(cell);
     _initializePeerHighlighting(cell);
   }
 }
 return grid;
}
</pre>
</div>
</div>
<div class="method"><h4 id="refresh">
<button class="show-code">Code</button>
void <strong>refresh</strong>([<a href="http://api.dartlang.org/dart_core/String.html">String</a> puzzleTitle]) <a class="anchor-link" href="#refresh"
              title="Permalink to BoardUI.refresh">#</a></h4>
<div class="doc">
<pre class="source">
void refresh([String puzzleTitle]) {
 _setTitle(puzzleTitle);
 for(var cell in cells) {
   _renderCellValue(cell);
   _setCellStyle(cell);
   _clearTemporaryCellStyle(cell);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="render">
<button class="show-code">Code</button>
void <strong>render</strong>([<a href="http://api.dartlang.org/dart_core/String.html">String</a> puzzleTitle]) <a class="anchor-link" href="#render"
              title="Permalink to BoardUI.render">#</a></h4>
<div class="doc">
<pre class="source">
void render([String puzzleTitle]) {
 var elements = new List&lt;Element&gt;();

 _titleElement = new HeadingElement.h3();
 elements.add(titleElement);

 var grid = constructGrid();
 elements.add(grid);

 _addGridElementsToDom(elements);
 _isRendered = true;
 refresh(puzzleTitle);
}
</pre>
</div>
</div>
<div class="method"><h4 id="renderGameState">
<button class="show-code">Code</button>
void <strong>renderGameState</strong>(<a href="../sudoku/GameState.html">GameState</a> gameState, [<a href="http://api.dartlang.org/dart_core/String.html">String</a> puzzleTitle]) <a class="anchor-link" href="#renderGameState"
              title="Permalink to BoardUI.renderGameState">#</a></h4>
<div class="doc">
<pre class="source">
void renderGameState(GameState gameState, [String puzzleTitle]) {
 if(_board != gameState.board)
   throw "The board for which the UI was created must match the board of the game state";

 _board.cellValues = gameState.cellValues;

 render(puzzleTitle);

 for(Cell cell in cells) {
   if(gameState.changedCells.contains(cell)) {
     var cellElement = _cellElementMap[cell];
     cellElement.classes.add(CSS.RECENTLY_MODIFIED_CELL);
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="update">
<button class="show-code">Code</button>
void <strong>update</strong>([<a href="http://api.dartlang.org/dart_core/String.html">String</a> puzzleTitle]) <a class="anchor-link" href="#update"
              title="Permalink to BoardUI.update">#</a></h4>
<div class="doc">
<pre class="source">
void update([String puzzleTitle]) {
 if(isRendered) {
   refresh(boardTitle);
 } else {
   render(boardTitle);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="updateCellValue">
<button class="show-code">Code</button>
void <strong>updateCellValue</strong>(<a href="../sudoku/Cell.html">Cell</a> cell, <a href="http://api.dartlang.org/dart_core/int.html">int</a> value) <a class="anchor-link" href="#updateCellValue"
              title="Permalink to BoardUI.updateCellValue">#</a></h4>
<div class="doc">
<pre class="source">
void updateCellValue(Cell cell, int value) {
 cell.value = value;
 _renderCellValue(cell);
 _updateStyle(cell);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-04-10 09:04:05.433</div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
